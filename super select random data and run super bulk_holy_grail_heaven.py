import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import pandas as pd
import random
from scipy.optimize import curve_fit
from scipy.stats import ks_2samp
from scipy.stats import pearsonr
import seaborn as sns
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.metrics import r2_score
from sklearn.model_selection import train_test_split
import statistics

# Daily_precipitation_data.txt - precipitation
# Daily_event_data.txt - load
# discharge_capsule.txt - flow
# Time capsule.txt - time fraction
# Daily_dates.txt - dates


# # The response 1 (also known as thonny response) need the data to be converted to log before it goes in to the analysis
# # The response 2 (also known as Pycharm response) need the data to go in - in its pure form without the log conversion
# 
# ## This code is designed to catch event flow in inorganic
# 
# ## Some active event values
# # inorganic hourly - 0.004166666666666667
# # inorganic daily - 
# # date_type = input('''Would this event be for be daily or hourly?
# # for Daily press - d
# # for hourly press - h
# # ''').lower()
# 
# 
item = 4
library = []
while item > 0:
    item -= 1
    date_type = 'd'
    if date_type == 'd':
        ## The event_data is meant to hold only the flow as the flow determines the event
        if item == 3:
            todo = 'no'
            #This is for the load file
            a = open('Daily_precipitation_data.txt', 'r')
            item_name = 'precipitation'
        elif item == 2:
            todo = 'no'
            #This is for the load file
            a = open('Daily_event_data.txt', 'r')
            item_name = 'Load'
        elif item == 1:
            todo = 'yes'
#             this is for the discharge file
            a = open('discharge_capsule.txt', 'r')
            item_name = 'Discharge'
        else:
            todo = 'no'
#             this isf or the time file
            a = open('Time capsule.txt', 'r')
            item_name = 'Time_fraction'
        a1 = open('Daily_Dates.txt', 'r')
        b = []
        b1 = []
        for lines in a:
            #c = we strip the lines with c, making every line an item
            c = lines.strip()
            d = lines.split()
            b.append(d)
        a.close()
        
        for lines in a1:
            #c = we strip the lines with c, making every line an item
            c = lines.strip()
            d = lines.split()
            b1.append(d)
        a1.close()

#         print(b)
#         print(len(b))
#         print('\n')
#         print(b1)
#         print(len(b1))
#         print('\n')

        Discharge = []
        Dates = []
        for elements in b:
            if len(elements) < 1:
                elements = '0'
                Discharge.append(float(elements))
            else:
                Discharge.append(float(elements[0]))
        
        for elements in b1:
            Dates.append((elements[0]))
        
        
        if item == 3:
            True_load = Discharge
        elif item == 2:
            True_load = Discharge
        elif item == 1:
            True_load = Discharge
        else:
            True_load = Discharge
#         print('\n')
#         print(f'''Discharge :
# {Discharge}''')
#         print(len(Discharge))
#         print('\n')        
#         print(f'''Discharge:
# {Discharge}''')
#         print(len(Discharge))
#         print('\n')
    #     print(f'''Dates:
    # {Dates}''')
    #     print(len(Dates))
    #     print('\n')
        percentage_discharge_change = ['event']
        for elements in range(1, len(Discharge)):
            y = Discharge[elements]
            change = y - Discharge[elements - 1]
            if Discharge[elements - 1 ] == 0:
                percentage_discharge_change.append('no flow')
            else:
                percent_change = (change/Discharge[elements - 1]) * 100
                percentage_discharge_change.append(percent_change)
            
        # print(f'''Discharge Percentage change
        # {percentage_discharge_change}''')
    #     print(len(percentage_discharge_change))
    #     print('\n')
        
    #     this part of the code prints out the changes in the flow and the serial number
        for elements in range(0, len(percentage_discharge_change)):
            c = f'{elements + 1} - {percentage_discharge_change[elements]}'
    #         print(c)
        high_compound_flow = []
        low_compound_flow = []
        combine_compound_flow = []
        events = []
        event_dates = []
        baseflow = []
        baseflow_dates = []
        event_endpoint = 0
        event_bunch = []
        catch_no = 0
        packer = 0
        caught_events = {}
        event_occuring = False
        switch = False
        
        if item == 3:
            active_event = float(input('At what discharge value does your active event begin: '))
        print('\n')
        if Discharge[0] > active_event:        
            event_occuring = True
            ## this part supplies the whole data for the analysis
        event_ends = 0
        base_compound = 0
        high_compound = 0
        for elements in range(0, len(Discharge)):
    #         event_ends = 0
    #         base_compound = 0
    #         high_compound = 0
            last_slope = -1
            if event_occuring and elements >= len(events):
                truncated_list = Discharge[elements:]
                section_dates = Dates[elements:]
                changing_flow = percentage_discharge_change[elements:]
                ## this part sections the whole data at event point and works on it until the event ends
                for elements1 in range(0, len(truncated_list)):
    #                 the part logs the event
                    if event_occuring:
                        if truncated_list[elements1] > active_event:
                            event_ends = 0
                            if elements1 > 0:
                                if changing_flow[elements1] == 'no flow':
                                    changing_flow[elements1] = 0.0000000001
                                if changing_flow[elements1] < 0:
                                    events.append(truncated_list[elements1])
                                    event_dates.append(section_dates[elements1])
                                    last_slope = changing_flow[elements1]
                                    baseflow.append('')
                                else:
                                    if last_slope < 0:
                                        high_compound += 1
                                        events.append(truncated_list[elements1])
                                        event_dates.append(section_dates[elements1])
                                        last_slope = changing_flow[elements1]
                                        baseflow.append('')
                                    else:
                                        events.append(truncated_list[elements1])
                                        event_dates.append(section_dates[elements1])
                                        last_slope = changing_flow[elements1]
                                        baseflow.append('')
                            else:
                                event_ends = 0
                                events.append(truncated_list[elements1])
                                event_dates.append(section_dates[elements1])
                                baseflow.append('')
    #                         the part chech if the event is ended and if base flow as begun
                        else:                        
                            event_ends += 1
                            if event_ends < 2:
                                events.append(truncated_list[elements1])
                                event_dates.append(section_dates[elements1])
                                drop_1 = truncated_list[elements1]
                                baseflow.append('')
                            #this part checks if a compount event begins after reaching baseflow treshold
                            else:
                                if truncated_list[elements1] <= drop_1:
                                    baseflow.append(truncated_list[elements1])
                                    baseflow_dates.append(section_dates[elements1])
                                    event_occuring = False
                                    switch = True
                                    event_endpoint = elements1
                                    events.append('')
                                else:
    #                             This part check if it is a slight bump, is significant to creat compound event
                                    if truncated_list[elements1] <= active_event:
                                        baseflow.append(truncated_list[elements1])
                                        baseflow_dates.append(section_dates[elements1])
                                        events.append('')
                                        event_occuring = False
                                        switch = True
                                        event_endpoint = elements1
                                    else:
                                        base_compound += 1
                                        events.append(truncated_list[elements1])
                                        event_dates.append(section_dates[elements1])
                                        baseflow.append('')
            else:
                if len(events) > 0 and len(events) >= packer and switch == True:
                    catch_no += 1
                    event_bunch.append(events)
                    packer = len(events)
                    caught_events[f'{catch_no} event '] = f'{event_dates[0]} - {event_dates[-1]}'
                    switch = False
                    if high_compound > 1:
                        if base_compound > 1:
                            combine_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                        else:
                            high_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                    elif base_compound > 1:
                        low_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                        
                if elements >= len(events):
                    if Discharge[elements] >= active_event:
                        event_ends = 0
                        event_dates = []
                        event_occuring = True
                        if event_occuring and elements >= len(events):
                            truncated_list = Discharge[elements:]
                            section_dates = Dates[elements:]
                            changing_flow = percentage_discharge_change[elements:]
                            ## this part sections the whole data at event point and works on it until the event ends
                            for elements1 in range(0, len(truncated_list)):
                #                 the part logs the event
                                if event_occuring:
                                    if truncated_list[elements1] > active_event:
                                        event_ends = 0
                                        if elements1 > 0:
                                            if changing_flow[elements1] == 'no flow':
                                                changing_flow[elements1] = 0.0000000001
                                            if changing_flow[elements1] < 0:
                                                events.append(truncated_list[elements1])
                                                event_dates.append(section_dates[elements1])
                                                last_slope = changing_flow[elements1]
                                                baseflow.append('')
                                            else:
                                                if last_slope < 0:
                                                    high_compound += 1
                                                    events.append(truncated_list[elements1])
                                                    event_dates.append(section_dates[elements1])
                                                    last_slope = changing_flow[elements1]
                                                    baseflow.append('')
                                                else:
                                                    events.append(truncated_list[elements1])
                                                    event_dates.append(section_dates[elements1])
                                                    last_slope = changing_flow[elements1]
                                                    baseflow.append('')
                                        else:
                                            event_ends = 0
                                            events.append(truncated_list[elements1])
                                            event_dates.append(section_dates[elements1])
                                            baseflow.append('')
                #                         the part chech if the event is ended and if base flow as begun
                                    else:                        
                                        event_ends += 1
                                        if event_ends < 2:
                                            events.append(truncated_list[elements1])
                                            event_dates.append(section_dates[elements1])
                                            drop_1 = truncated_list[elements1]
                                            baseflow.append('')
                                        #this part checks if a compount event begins after reaching baseflow treshold
                                        else:
                                            if truncated_list[elements1] <= drop_1:
                                                baseflow.append(truncated_list[elements1])
                                                baseflow_dates.append(section_dates[elements1])
                                                event_occuring = False
                                                switch = True
                                                event_endpoint = elements1
                                                events.append('')
                                            else:
                #                             This part check if it is a slight bump, is significant to creat compound event
                                                if truncated_list[elements1] <= active_event:
                                                    baseflow.append(truncated_list[elements1])
                                                    baseflow_dates.append(section_dates[elements1])
                                                    events.append('')
                                                    event_occuring = False
                                                    switch = True
                                                    event_endpoint = elements1
                                                else:
                                                    base_compound += 1
                                                    events.append(truncated_list[elements1])
                                                    event_dates.append(section_dates[elements1])
                                                    baseflow.append('')
                        else:
                            if len(events) > 0 and len(events) >= packer and switch == True:
                                catch_no += 1
                                event_bunch.append(events)
                                packer = len(events)
                                caught_events[f'{catch_no} event '] = f'{event_dates[0]} - {event_dates[-1]}'
                                switch = False
                                if high_compound > 1:
                                    if base_compound > 1:
                                        combine_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                                    else:
                                        high_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                                elif base_compound > 1:
                                    low_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
             
                    else:
                        baseflow.append(Discharge[elements])
                        baseflow_dates.append(Dates[elements])
                        events.append('')
                        
#         print(event_endpoint)            
#         print(f'''events -
#         {events}''')
#         print(len(events))
#         print('\n')
#         print(f'''event_dates -
#         {event_dates}''')
#         print(len(event_dates))
#         print('\n')
#         print(f'''Baseflow -
#         {baseflow}''')
#         print(len(baseflow))
#         print('\n')
#         print(f'''Baseflow Dates -
#         {baseflow_dates}''')
#         print(len(baseflow_dates))
#         print('\n')
#         print(f'''Event Bunch -
#         {event_bunch}''')
#         print(len(event_bunch))
#         print('\n')
        if todo == 'yes':
#             print(f'''Caught_event -
#             {caught_events}''')
            print(f'You had {len(caught_events)} events')
#             print('\n')
#         print(f'Number of events - {len(caught_events)}')
#         print('\n')
        # print(f'''Combine Compound Flows - 
        # {combine_compound_flow}''')
        # print(f'You have {len(combine_compound_flow)} combine compound flows')
        # print('\n')
        # print(f'''High Compound flows - 
        # {high_compound_flow}''')
        # print(f'You have {len(high_compound_flow)} high compound flows')
        # print('\n')
        # print(f'''Low Compound Flows -
        # {low_compound_flow}''')
        # print(f'You have {len(low_compound_flow)} low compound flows')
        # print('\n')
        
        if todo == 'yes':
            print('EVENTS')
        #     event_full = events
#             print(events)
#             print(len(events))
    #     for elements in events:
    #         print(elements)
    #     print('end')
    print('\n')
    print('\n')
    print('\n')


    # ABOVE IS PICKING OUT EVENTS

    usable_events = []

    # After you put in the data for the given year, you have to put in the fertilizer applicaton dates. 
    # the fertilizer application day it the takeout1 (the list called takeout1)
    # field = input('''What fields is this:
    # for inorganic - press b
    # for Palmyra - press P
    # for organic - press c
    # ''').lower()
    # Note: to run the code, you have to unmute the concentration_pred to run the code, I had to mute it
    # because it makes the code slow
    # field = 'inorganic'


    # if field == 'b':
        
    # longer (5 years data)
    concentration_pred = True_load
# ['0.002739726', '0.005479452', '0.008219178', '0.010958904', '0.01369863', '0.016438356', '0.019178082', '0.021917808', '0.024657534', '0.02739726', '0.030136986', '0.032876712', '0.035616438', '0.038356164', '0.04109589', '0.043835616', '0.046575342', '0.049315068', '0.052054795', '0.054794521', '0.057534247', '0.060273973', '0.063013699', '0.065753425', '0.068493151', '0.071232877', '0.073972603', '0.076712329', '0.079452055', '0.082191781', '0.084931507', '0.087671233', '0.090410959', '0.093150685', '0.095890411', '0.098630137', '0.101369863', '0.104109589', '0.106849315', '0.109589041', '0.112328767', '0.115068493', '0.117808219', '0.120547945', '0.123287671', '0.126027397', '0.128767123', '0.131506849', '0.134246575', '0.136986301', '0.139726027', '0.142465753', '0.145205479', '0.147945205', '0.150684932', '0.153424658', '0.156164384', '0.15890411', '0.161643836', '0.164383562', '0.167123288', '0.169863014', '0.17260274', '0.175342466', '0.178082192', '0.180821918', '0.183561644', '0.18630137', '0.189041096', '0.191780822', '0.194520548', '0.197260274', '0.2', '0.202739726', '0.205479452', '0.208219178', '0.210958904', '0.21369863', '0.216438356', '0.219178082', '0.221917808', '0.224657534', '0.22739726', '0.230136986', '0.232876712', '0.235616438', '0.238356164', '0.24109589', '0.243835616', '0.246575342', '0.249315068', '0.252054795', '0.254794521', '0.257534247', '0.260273973', '0.263013699', '0.265753425', '0.268493151', '0.271232877', '0.273972603', '0.276712329', '0.279452055', '0.282191781', '0.284931507', '0.287671233', '0.290410959', '0.293150685', '0.295890411', '0.298630137', '0.301369863', '0.304109589', '0.306849315', '0.309589041', '0.312328767', '0.315068493', '0.317808219', '0.320547945', '0.323287671', '0.326027397', '0.328767123', '0.331506849', '0.334246575', '0.336986301', '0.339726027', '0.342465753', '0.345205479', '0.347945205', '0.350684932', '0.353424658', '0.356164384', '0.35890411', '0.361643836', '0.364383562', '0.367123288', '0.369863014', '0.37260274', '0.375342466', '0.378082192', '0.380821918', '0.383561644', '0.38630137', '0.389041096', '0.391780822', '0.394520548', '0.397260274', '0.4', '0.402739726', '0.405479452', '0.408219178', '0.410958904', '0.41369863', '0.416438356', '0.419178082', '0.421917808', '0.424657534', '0.42739726', '0.430136986', '0.432876712', '0.435616438', '0.438356164', '0.44109589', '0.443835616', '0.446575342', '0.449315068', '0.452054795', '0.454794521', '0.457534247', '0.460273973', '0.463013699', '0.465753425', '0.468493151', '0.471232877', '0.473972603', '0.476712329', '0.479452055', '0.482191781', '0.484931507', '0.487671233', '0.490410959', '0.493150685', '0.495890411', '0.498630137', '0.501369863', '0.504109589', '0.506849315', '0.509589041', '0.512328767', '0.515068493', '0.517808219', '0.520547945', '0.523287671', '0.526027397', '0.528767123', '0.531506849', '0.534246575', '0.536986301', '0.539726027', '0.542465753', '0.545205479', '0.547945205', '0.550684932', '0.553424658', '0.556164384', '0.55890411', '0.561643836', '0.564383562', '0.567123288', '0.569863014', '0.57260274', '0.575342466', '0.578082192', '0.580821918', '0.583561644', '0.58630137', '0.589041096', '0.591780822', '0.594520548', '0.597260274', '0.6', '0.602739726', '0.605479452', '0.608219178', '0.610958904', '0.61369863', '0.616438356', '0.619178082', '0.621917808', '0.624657534', '0.62739726', '0.630136986', '0.632876712', '0.635616438', '0.638356164', '0.64109589', '0.643835616', '0.646575342', '0.649315068', '0.652054795', '0.654794521', '0.657534247', '0.660273973', '0.663013699', '0.665753425', '0.668493151', '0.671232877', '0.673972603', '0.676712329', '0.679452055', '0.682191781', '0.684931507', '0.687671233', '0.690410959', '0.693150685', '0.695890411', '0.698630137', '0.701369863', '0.704109589', '0.706849315', '0.709589041', '0.712328767', '0.715068493', '0.717808219', '0.720547945', '0.723287671', '0.726027397', '0.728767123', '0.731506849', '0.734246575', '0.736986301', '0.739726027', '0.742465753', '0.745205479', '0.747945205', '0.750684932', '0.753424658', '0.756164384', '0.75890411', '0.761643836', '0.764383562', '0.767123288', '0.769863014', '0.77260274', '0.775342466', '0.778082192', '0.780821918', '0.783561644', '0.78630137', '0.789041096', '0.791780822', '0.794520548', '0.797260274', '0.8', '0.802739726', '0.805479452', '0.808219178', '0.810958904', '0.81369863', '0.816438356', '0.819178082', '0.821917808', '0.824657534', '0.82739726', '0.830136986', '0.832876712', '0.835616438', '0.838356164', '0.84109589', '0.843835616', '0.846575342', '0.849315068', '0.852054795', '0.854794521', '0.857534247', '0.860273973', '0.863013699', '0.865753425', '0.868493151', '0.871232877', '0.873972603', '0.876712329', '0.879452055', '0.882191781', '0.884931507', '0.887671233', '0.890410959', '0.893150685', '0.895890411', '0.898630137', '0.901369863', '0.904109589', '0.906849315', '0.909589041', '0.912328767', '0.915068493', '0.917808219', '0.920547945', '0.923287671', '0.926027397', '0.928767123', '0.931506849', '0.934246575', '0.936986301', '0.939726027', '0.942465753', '0.945205479', '0.947945205', '0.950684932', '0.953424658', '0.956164384', '0.95890411', '0.961643836', '0.964383562', '0.967123288', '0.969863014', '0.97260274', '0.975342466', '0.978082192', '0.980821918', '0.983561644', '0.98630137', '0.989041096', '0.991780822', '0.994520548', '0.997260274', '1', '0.002739726', '0.005479452', '0.008219178', '0.010958904', '0.01369863', '0.016438356', '0.019178082', '0.021917808', '0.024657534', '0.02739726', '0.030136986', '0.032876712', '0.035616438', '0.038356164', '0.04109589', '0.043835616', '0.046575342', '0.049315068', '0.052054795', '0.054794521', '0.057534247', '0.060273973', '0.063013699', '0.065753425', '0.068493151', '0.071232877', '0.073972603', '0.076712329', '0.079452055', '0.082191781', '0.084931507', '0.087671233', '0.090410959', '0.093150685', '0.095890411', '0.098630137', '0.101369863', '0.104109589', '0.106849315', '0.109589041', '0.112328767', '0.115068493', '0.117808219', '0.120547945', '0.123287671', '0.126027397', '0.128767123', '0.131506849', '0.134246575', '0.136986301', '0.139726027', '0.142465753', '0.145205479', '0.147945205', '0.150684932', '0.153424658', '0.156164384', '0.15890411', '0.161643836', '0.164383562', '0.167123288', '0.169863014', '0.17260274', '0.175342466', '0.178082192', '0.180821918', '0.183561644', '0.18630137', '0.189041096', '0.191780822', '0.194520548', '0.197260274', '0.2', '0.202739726', '0.205479452', '0.208219178', '0.210958904', '0.21369863', '0.216438356', '0.219178082', '0.221917808', '0.224657534', '0.22739726', '0.230136986', '0.232876712', '0.235616438', '0.238356164', '0.24109589', '0.243835616', '0.246575342', '0.249315068', '0.252054795', '0.254794521', '0.257534247', '0.260273973', '0.263013699', '0.265753425', '0.268493151', '0.271232877', '0.273972603', '0.276712329', '0.279452055', '0.282191781', '0.284931507', '0.287671233', '0.290410959', '0.293150685', '0.295890411', '0.298630137', '0.301369863', '0.304109589', '0.306849315', '0.309589041', '0.312328767', '0.315068493', '0.317808219', '0.320547945', '0.323287671', '0.326027397', '0.328767123', '0.331506849', '0.334246575', '0.336986301', '0.339726027', '0.342465753', '0.345205479', '0.347945205', '0.350684932', '0.353424658', '0.356164384', '0.35890411', '0.361643836', '0.364383562', '0.367123288', '0.369863014', '0.37260274', '0.375342466', '0.378082192', '0.380821918', '0.383561644', '0.38630137', '0.389041096', '0.391780822', '0.394520548', '0.397260274', '0.4', '0.402739726', '0.405479452', '0.408219178', '0.410958904', '0.41369863', '0.416438356', '0.419178082', '0.421917808', '0.424657534', '0.42739726', '0.430136986', '0.432876712', '0.435616438', '0.438356164', '0.44109589', '0.443835616', '0.446575342', '0.449315068', '0.452054795', '0.454794521', '0.457534247', '0.460273973', '0.463013699', '0.465753425', '0.468493151', '0.471232877', '0.473972603', '0.476712329', '0.479452055', '0.482191781', '0.484931507', '0.487671233', '0.490410959', '0.493150685', '0.495890411', '0.498630137', '0.501369863', '0.504109589', '0.506849315', '0.509589041', '0.512328767', '0.515068493', '0.517808219', '0.520547945', '0.523287671', '0.526027397', '0.528767123', '0.531506849', '0.534246575', '0.536986301', '0.539726027', '0.542465753', '0.545205479', '0.547945205', '0.550684932', '0.553424658', '0.556164384', '0.55890411', '0.561643836', '0.564383562', '0.567123288', '0.569863014', '0.57260274', '0.575342466', '0.578082192', '0.580821918', '0.583561644', '0.58630137', '0.589041096', '0.591780822', '0.594520548', '0.597260274', '0.6', '0.602739726', '0.605479452', '0.608219178', '0.610958904', '0.61369863', '0.616438356', '0.619178082', '0.621917808', '0.624657534', '0.62739726', '0.630136986', '0.632876712', '0.635616438', '0.638356164', '0.64109589', '0.643835616', '0.646575342', '0.649315068', '0.652054795', '0.654794521', '0.657534247', '0.660273973', '0.663013699', '0.665753425', '0.668493151', '0.671232877', '0.673972603', '0.676712329', '0.679452055', '0.682191781', '0.684931507', '0.687671233', '0.690410959', '0.693150685', '0.695890411', '0.698630137', '0.701369863', '0.704109589', '0.706849315', '0.709589041', '0.712328767', '0.715068493', '0.717808219', '0.720547945', '0.723287671', '0.726027397', '0.728767123', '0.731506849', '0.734246575', '0.736986301', '0.739726027', '0.742465753', '0.745205479', '0.747945205', '0.750684932', '0.753424658', '0.756164384', '0.75890411', '0.761643836', '0.764383562', '0.767123288', '0.769863014', '0.77260274', '0.775342466', '0.778082192', '0.780821918', '0.783561644', '0.78630137', '0.789041096', '0.791780822', '0.794520548', '0.797260274', '0.8', '0.802739726', '0.805479452', '0.808219178', '0.810958904', '0.81369863', '0.816438356', '0.819178082', '0.821917808', '0.824657534', '0.82739726', '0.830136986', '0.832876712', '0.835616438', '0.838356164', '0.84109589', '0.843835616', '0.846575342', '0.849315068', '0.852054795', '0.854794521', '0.857534247', '0.860273973', '0.863013699', '0.865753425', '0.868493151', '0.871232877', '0.873972603', '0.876712329', '0.879452055', '0.882191781', '0.884931507', '0.887671233', '0.890410959', '0.893150685', '0.895890411', '0.898630137', '0.901369863', '0.904109589', '0.906849315', '0.909589041', '0.912328767', '0.915068493', '0.917808219', '0.920547945', '0.923287671', '0.926027397', '0.928767123', '0.931506849', '0.934246575', '0.936986301', '0.939726027', '0.942465753', '0.945205479', '0.947945205', '0.950684932', '0.953424658', '0.956164384', '0.95890411', '0.961643836', '0.964383562', '0.967123288', '0.969863014', '0.97260274', '0.975342466', '0.978082192', '0.980821918', '0.983561644', '0.98630137', '0.989041096', '0.991780822', '0.994520548', '0.997260274', '1', '1', '0.002739726', '0.005479452', '0.008219178', '0.010958904', '0.01369863', '0.016438356', '0.019178082', '0.021917808', '0.024657534', '0.02739726', '0.030136986', '0.032876712', '0.035616438', '0.038356164', '0.04109589', '0.043835616', '0.046575342', '0.049315068', '0.052054795', '0.054794521', '0.057534247', '0.060273973', '0.063013699', '0.065753425', '0.068493151', '0.071232877', '0.073972603', '0.076712329', '0.079452055', '0.082191781', '0.084931507', '0.087671233', '0.090410959', '0.093150685', '0.095890411', '0.098630137', '0.101369863', '0.104109589', '0.106849315', '0.109589041', '0.112328767', '0.115068493', '0.117808219', '0.120547945', '0.123287671', '0.126027397', '0.128767123', '0.131506849', '0.134246575', '0.136986301', '0.139726027', '0.142465753', '0.145205479', '0.147945205', '0.150684932', '0.153424658', '0.156164384', '0.15890411', '0.161643836', '0.164383562', '0.167123288', '0.169863014', '0.17260274', '0.175342466', '0.178082192', '0.180821918', '0.183561644', '0.18630137', '0.189041096', '0.191780822', '0.194520548', '0.197260274', '0.2', '0.202739726', '0.205479452', '0.208219178', '0.210958904', '0.21369863', '0.216438356', '0.219178082', '0.221917808', '0.224657534', '0.22739726', '0.230136986', '0.232876712', '0.235616438', '0.238356164', '0.24109589', '0.243835616', '0.246575342', '0.249315068', '0.252054795', '0.254794521', '0.257534247', '0.260273973', '0.263013699', '0.265753425', '0.268493151', '0.271232877', '0.273972603', '0.276712329', '0.279452055', '0.282191781', '0.284931507', '0.287671233', '0.290410959', '0.293150685', '0.295890411', '0.298630137', '0.301369863', '0.304109589', '0.306849315', '0.309589041', '0.312328767', '0.315068493', '0.317808219', '0.320547945', '0.323287671', '0.326027397', '0.328767123', '0.331506849', '0.334246575', '0.336986301', '0.339726027', '0.342465753', '0.345205479', '0.347945205', '0.350684932', '0.353424658', '0.356164384', '0.35890411', '0.361643836', '0.364383562', '0.367123288', '0.369863014', '0.37260274', '0.375342466', '0.378082192', '0.380821918', '0.383561644', '0.38630137', '0.389041096', '0.391780822', '0.394520548', '0.397260274', '0.4', '0.402739726', '0.405479452', '0.408219178', '0.410958904', '0.41369863', '0.416438356', '0.419178082', '0.421917808', '0.424657534', '0.42739726', '0.430136986', '0.432876712', '0.435616438', '0.438356164', '0.44109589', '0.443835616', '0.446575342', '0.449315068', '0.452054795', '0.454794521', '0.457534247', '0.460273973', '0.463013699', '0.465753425', '0.468493151', '0.471232877', '0.473972603', '0.476712329', '0.479452055', '0.482191781', '0.484931507', '0.487671233', '0.490410959', '0.493150685', '0.495890411', '0.498630137', '0.501369863', '0.504109589', '0.506849315', '0.509589041', '0.512328767', '0.515068493', '0.517808219', '0.520547945', '0.523287671', '0.526027397', '0.528767123', '0.531506849', '0.534246575', '0.536986301', '0.539726027', '0.542465753', '0.545205479', '0.547945205', '0.550684932', '0.553424658', '0.556164384', '0.55890411', '0.561643836', '0.564383562', '0.567123288', '0.569863014', '0.57260274', '0.575342466', '0.578082192', '0.580821918', '0.583561644', '0.58630137', '0.589041096', '0.591780822', '0.594520548', '0.597260274', '0.6', '0.602739726', '0.605479452', '0.608219178', '0.610958904', '0.61369863', '0.616438356', '0.619178082', '0.621917808', '0.624657534', '0.62739726', '0.630136986', '0.632876712', '0.635616438', '0.638356164', '0.64109589', '0.643835616', '0.646575342', '0.649315068', '0.652054795', '0.654794521', '0.657534247', '0.660273973', '0.663013699', '0.665753425', '0.668493151', '0.671232877', '0.673972603', '0.676712329', '0.679452055', '0.682191781', '0.684931507', '0.687671233', '0.690410959', '0.693150685', '0.695890411', '0.698630137', '0.701369863', '0.704109589', '0.706849315', '0.709589041', '0.712328767', '0.715068493', '0.717808219', '0.720547945', '0.723287671', '0.726027397', '0.728767123', '0.731506849', '0.734246575', '0.736986301', '0.739726027', '0.742465753', '0.745205479', '0.747945205', '0.750684932', '0.753424658', '0.756164384', '0.75890411', '0.761643836', '0.764383562', '0.767123288', '0.769863014', '0.77260274', '0.775342466', '0.778082192', '0.780821918', '0.783561644', '0.78630137', '0.789041096', '0.791780822', '0.794520548', '0.797260274', '0.8', '0.802739726', '0.805479452', '0.808219178', '0.810958904', '0.81369863', '0.816438356', '0.819178082', '0.821917808', '0.824657534', '0.82739726', '0.830136986', '0.832876712', '0.835616438', '0.838356164', '0.84109589', '0.843835616', '0.846575342', '0.849315068', '0.852054795', '0.854794521', '0.857534247', '0.860273973', '0.863013699', '0.865753425', '0.868493151', '0.871232877', '0.873972603', '0.876712329', '0.879452055', '0.882191781', '0.884931507', '0.887671233', '0.890410959', '0.893150685', '0.895890411', '0.898630137', '0.901369863', '0.904109589', '0.906849315', '0.909589041', '0.912328767', '0.915068493', '0.917808219', '0.920547945', '0.923287671', '0.926027397', '0.928767123', '0.931506849', '0.934246575', '0.936986301', '0.939726027', '0.942465753', '0.945205479', '0.947945205', '0.950684932', '0.953424658', '0.956164384', '0.95890411', '0.961643836', '0.964383562', '0.967123288', '0.969863014', '0.97260274', '0.975342466', '0.978082192', '0.980821918', '0.983561644', '0.98630137', '0.989041096', '0.991780822', '0.994520548', '0.997260274', '1', '0.002739726', '0.005479452', '0.008219178', '0.010958904', '0.01369863', '0.016438356', '0.019178082', '0.021917808', '0.024657534', '0.02739726', '0.030136986', '0.032876712', '0.035616438', '0.038356164', '0.04109589', '0.043835616', '0.046575342', '0.049315068', '0.052054795', '0.054794521', '0.057534247', '0.060273973', '0.063013699', '0.065753425', '0.068493151', '0.071232877', '0.073972603', '0.076712329', '0.079452055', '0.082191781', '0.084931507', '0.087671233', '0.090410959', '0.093150685', '0.095890411', '0.098630137', '0.101369863', '0.104109589', '0.106849315', '0.109589041', '0.112328767', '0.115068493', '0.117808219', '0.120547945', '0.123287671', '0.126027397', '0.128767123', '0.131506849', '0.134246575', '0.136986301', '0.139726027', '0.142465753', '0.145205479', '0.147945205', '0.150684932', '0.153424658', '0.156164384', '0.15890411', '0.161643836', '0.164383562', '0.167123288', '0.169863014', '0.17260274', '0.175342466', '0.178082192', '0.180821918', '0.183561644', '0.18630137', '0.189041096', '0.191780822', '0.194520548', '0.197260274', '0.2', '0.202739726', '0.205479452', '0.208219178', '0.210958904', '0.21369863', '0.216438356', '0.219178082', '0.221917808', '0.224657534', '0.22739726', '0.230136986', '0.232876712', '0.235616438', '0.238356164', '0.24109589', '0.243835616', '0.246575342', '0.249315068', '0.252054795', '0.254794521', '0.257534247', '0.260273973', '0.263013699', '0.265753425', '0.268493151', '0.271232877', '0.273972603', '0.276712329', '0.279452055', '0.282191781', '0.284931507', '0.287671233', '0.290410959', '0.293150685', '0.295890411', '0.298630137', '0.301369863', '0.304109589', '0.306849315', '0.309589041', '0.312328767', '0.315068493', '0.317808219', '0.320547945', '0.323287671', '0.326027397', '0.328767123', '0.331506849', '0.334246575', '0.336986301', '0.339726027', '0.342465753', '0.345205479', '0.347945205', '0.350684932', '0.353424658', '0.356164384', '0.35890411', '0.361643836', '0.364383562', '0.367123288', '0.369863014', '0.37260274', '0.375342466', '0.378082192', '0.380821918', '0.383561644', '0.38630137', '0.389041096', '0.391780822', '0.394520548', '0.397260274', '0.4', '0.402739726', '0.405479452', '0.408219178', '0.410958904', '0.41369863', '0.416438356', '0.419178082', '0.421917808', '0.424657534', '0.42739726', '0.430136986', '0.432876712', '0.435616438', '0.438356164', '0.44109589', '0.443835616', '0.446575342', '0.449315068', '0.452054795', '0.454794521', '0.457534247', '0.460273973', '0.463013699', '0.465753425', '0.468493151', '0.471232877', '0.473972603', '0.476712329', '0.479452055', '0.482191781', '0.484931507', '0.487671233', '0.490410959', '0.493150685', '0.495890411', '0.498630137', '0.501369863', '0.504109589', '0.506849315', '0.509589041', '0.512328767', '0.515068493', '0.517808219', '0.520547945', '0.523287671', '0.526027397', '0.528767123', '0.531506849', '0.534246575', '0.536986301', '0.539726027', '0.542465753', '0.545205479', '0.547945205', '0.550684932', '0.553424658', '0.556164384', '0.55890411', '0.561643836', '0.564383562', '0.567123288', '0.569863014', '0.57260274', '0.575342466', '0.578082192', '0.580821918', '0.583561644', '0.58630137', '0.589041096', '0.591780822', '0.594520548', '0.597260274', '0.6', '0.602739726', '0.605479452', '0.608219178', '0.610958904', '0.61369863', '0.616438356', '0.619178082', '0.621917808', '0.624657534', '0.62739726', '0.630136986', '0.632876712', '0.635616438', '0.638356164', '0.64109589', '0.643835616', '0.646575342', '0.649315068', '0.652054795', '0.654794521', '0.657534247', '0.660273973', '0.663013699', '0.665753425', '0.668493151', '0.671232877', '0.673972603', '0.676712329', '0.679452055', '0.682191781', '0.684931507', '0.687671233', '0.690410959', '0.693150685', '0.695890411', '0.698630137', '0.701369863', '0.704109589', '0.706849315', '0.709589041', '0.712328767', '0.715068493', '0.717808219', '0.720547945', '0.723287671', '0.726027397', '0.728767123', '0.731506849', '0.734246575', '0.736986301', '0.739726027', '0.742465753', '0.745205479', '0.747945205', '0.750684932', '0.753424658', '0.756164384', '0.75890411', '0.761643836', '0.764383562', '0.767123288', '0.769863014', '0.77260274', '0.775342466', '0.778082192', '0.780821918', '0.783561644', '0.78630137', '0.789041096', '0.791780822', '0.794520548', '0.797260274', '0.8', '0.802739726', '0.805479452', '0.808219178', '0.810958904', '0.81369863', '0.816438356', '0.819178082', '0.821917808', '0.824657534', '0.82739726', '0.830136986', '0.832876712', '0.835616438', '0.838356164', '0.84109589', '0.843835616', '0.846575342', '0.849315068', '0.852054795', '0.854794521', '0.857534247', '0.860273973', '0.863013699', '0.865753425', '0.868493151', '0.871232877', '0.873972603', '0.876712329', '0.879452055', '0.882191781', '0.884931507', '0.887671233', '0.890410959', '0.893150685', '0.895890411', '0.898630137', '0.901369863', '0.904109589', '0.906849315', '0.909589041', '0.912328767', '0.915068493', '0.917808219', '0.920547945', '0.923287671', '0.926027397', '0.928767123', '0.931506849', '0.934246575', '0.936986301', '0.939726027', '0.942465753', '0.945205479', '0.947945205', '0.950684932', '0.953424658', '0.956164384', '0.95890411', '0.961643836', '0.964383562', '0.967123288', '0.969863014', '0.97260274', '0.975342466', '0.978082192', '0.980821918', '0.983561644', '0.98630137', '0.989041096', '0.991780822', '0.994520548', '0.997260274', '1', '0.002739726', '0.005479452', '0.008219178', '0.010958904', '0.01369863', '0.016438356', '0.019178082', '0.021917808', '0.024657534', '0.02739726', '0.030136986', '0.032876712', '0.035616438', '0.038356164', '0.04109589', '0.043835616', '0.046575342', '0.049315068', '0.052054795', '0.054794521', '0.057534247', '0.060273973', '0.063013699', '0.065753425', '0.068493151', '0.071232877', '0.073972603', '0.076712329', '0.079452055', '0.082191781', '0.084931507', '0.087671233', '0.090410959', '0.093150685', '0.095890411', '0.098630137', '0.101369863', '0.104109589', '0.106849315', '0.109589041', '0.112328767', '0.115068493', '0.117808219', '0.120547945', '0.123287671', '0.126027397', '0.128767123', '0.131506849', '0.134246575', '0.136986301', '0.139726027', '0.142465753', '0.145205479', '0.147945205', '0.150684932', '0.153424658', '0.156164384', '0.15890411', '0.161643836', '0.164383562', '0.167123288', '0.169863014', '0.17260274', '0.175342466', '0.178082192', '0.180821918', '0.183561644', '0.18630137', '0.189041096', '0.191780822', '0.194520548', '0.197260274', '0.2', '0.202739726', '0.205479452', '0.208219178', '0.210958904', '0.21369863', '0.216438356', '0.219178082', '0.221917808', '0.224657534', '0.22739726', '0.230136986', '0.232876712', '0.235616438', '0.238356164', '0.24109589', '0.243835616', '0.246575342', '0.249315068', '0.252054795', '0.254794521', '0.257534247', '0.260273973', '0.263013699', '0.265753425', '0.268493151', '0.271232877', '0.273972603', '0.276712329', '0.279452055', '0.282191781', '0.284931507', '0.287671233', '0.290410959', '0.293150685', '0.295890411', '0.298630137', '0.301369863', '0.304109589', '0.306849315', '0.309589041', '0.312328767', '0.315068493', '0.317808219', '0.320547945', '0.323287671', '0.326027397', '0.328767123', '0.331506849', '0.334246575', '0.336986301', '0.339726027', '0.342465753', '0.345205479', '0.347945205', '0.350684932', '0.353424658', '0.356164384', '0.35890411', '0.361643836', '0.364383562', '0.367123288', '0.369863014', '0.37260274', '0.375342466', '0.378082192', '0.380821918', '0.383561644', '0.38630137', '0.389041096', '0.391780822', '0.394520548', '0.397260274', '0.4', '0.402739726', '0.405479452', '0.408219178', '0.410958904', '0.41369863', '0.416438356', '0.419178082', '0.421917808', '0.424657534', '0.42739726', '0.430136986', '0.432876712', '0.435616438', '0.438356164', '0.44109589', '0.443835616', '0.446575342', '0.449315068', '0.452054795', '0.454794521', '0.457534247', '0.460273973', '0.463013699', '0.465753425', '0.468493151', '0.471232877', '0.473972603', '0.476712329', '0.479452055', '0.482191781', '0.484931507', '0.487671233', '0.490410959', '0.493150685', '0.495890411', '0.498630137', '0.501369863', '0.504109589', '0.506849315', '0.509589041', '0.512328767', '0.515068493', '0.517808219', '0.520547945', '0.523287671', '0.526027397', '0.528767123', '0.531506849', '0.534246575', '0.536986301', '0.539726027', '0.542465753', '0.545205479', '0.547945205', '0.550684932', '0.553424658', '0.556164384', '0.55890411', '0.561643836', '0.564383562', '0.567123288', '0.569863014', '0.57260274', '0.575342466', '0.578082192', '0.580821918', '0.583561644', '0.58630137', '0.589041096', '0.591780822', '0.594520548', '0.597260274', '0.6', '0.602739726', '0.605479452', '0.608219178', '0.610958904', '0.61369863', '0.616438356', '0.619178082', '0.621917808', '0.624657534', '0.62739726', '0.630136986', '0.632876712', '0.635616438', '0.638356164', '0.64109589', '0.643835616', '0.646575342', '0.649315068', '0.652054795', '0.654794521', '0.657534247', '0.660273973', '0.663013699', '0.665753425', '0.668493151', '0.671232877', '0.673972603', '0.676712329', '0.679452055', '0.682191781', '0.684931507', '0.687671233', '0.690410959', '0.693150685', '0.695890411', '0.698630137', '0.701369863', '0.704109589', '0.706849315', '0.709589041', '0.712328767', '0.715068493', '0.717808219', '0.720547945', '0.723287671', '0.726027397', '0.728767123', '0.731506849', '0.734246575', '0.736986301', '0.739726027', '0.742465753', '0.745205479', '0.747945205', '0.750684932', '0.753424658', '0.756164384', '0.75890411', '0.761643836', '0.764383562', '0.767123288', '0.769863014', '0.77260274', '0.775342466', '0.778082192', '0.780821918', '0.783561644', '0.78630137', '0.789041096', '0.791780822', '0.794520548', '0.797260274', '0.8', '0.802739726', '0.805479452', '0.808219178', '0.810958904', '0.81369863', '0.816438356', '0.819178082', '0.821917808', '0.824657534', '0.82739726', '0.830136986', '0.832876712', '0.835616438', '0.838356164', '0.84109589', '0.843835616', '0.846575342', '0.849315068', '0.852054795', '0.854794521', '0.857534247', '0.860273973', '0.863013699', '0.865753425', '0.868493151', '0.871232877', '0.873972603', '0.876712329', '0.879452055', '0.882191781', '0.884931507', '0.887671233', '0.890410959', '0.893150685', '0.895890411', '0.898630137', '0.901369863', '0.904109589', '0.906849315', '0.909589041', '0.912328767', '0.915068493', '0.917808219', '0.920547945', '0.923287671', '0.926027397', '0.928767123', '0.931506849', '0.934246575', '0.936986301', '0.939726027', '0.942465753', '0.945205479', '0.947945205', '0.950684932', '0.953424658', '0.956164384', '0.95890411', '0.961643836', '0.964383562', '0.967123288', '0.969863014', '0.97260274', '0.975342466', '0.978082192', '0.980821918', '0.983561644', '0.98630137', '0.989041096', '0.991780822', '0.994520548', '0.997260274', '1']



    # Shorter (1 year data)
#     concentration_pred = ['0.002739726', '0.005479452', '0.008219178', '0.010958904', '0.01369863', '0.016438356', '0.019178082', '0.021917808', '0.024657534', '0.02739726', '0.030136986', '0.032876712', '0.035616438', '0.038356164', '0.04109589', '0.043835616', '0.046575342', '0.049315068', '0.052054795', '0.054794521', '0.057534247', '0.060273973', '0.063013699', '0.065753425', '0.068493151', '0.071232877', '0.073972603', '0.076712329', '0.079452055', '0.082191781', '0.084931507', '0.087671233', '0.090410959', '0.093150685', '0.095890411', '0.098630137', '0.101369863', '0.104109589', '0.106849315', '0.109589041', '0.112328767', '0.115068493', '0.117808219', '0.120547945', '0.123287671', '0.126027397', '0.128767123', '0.131506849', '0.134246575', '0.136986301', '0.139726027', '0.142465753', '0.145205479', '0.147945205', '0.150684932', '0.153424658', '0.156164384', '0.15890411', '0.161643836', '0.164383562', '0.167123288', '0.169863014', '0.17260274', '0.175342466', '0.178082192', '0.180821918', '0.183561644', '0.18630137', '0.189041096', '0.191780822', '0.194520548', '0.197260274', '0.2', '0.202739726', '0.205479452', '0.208219178', '0.210958904', '0.21369863', '0.216438356', '0.219178082', '0.221917808', '0.224657534', '0.22739726', '0.230136986', '0.232876712', '0.235616438', '0.238356164', '0.24109589', '0.243835616', '0.246575342', '0.249315068', '0.252054795', '0.254794521', '0.257534247', '0.260273973', '0.263013699', '0.265753425', '0.268493151', '0.271232877', '0.273972603', '0.276712329', '0.279452055', '0.282191781', '0.284931507', '0.287671233', '0.290410959', '0.293150685', '0.295890411', '0.298630137', '0.301369863', '0.304109589', '0.306849315', '0.309589041', '0.312328767', '0.315068493', '0.317808219', '0.320547945', '0.323287671', '0.326027397', '0.328767123', '0.331506849', '0.334246575', '0.336986301', '0.339726027', '0.342465753', '0.345205479', '0.347945205', '0.350684932', '0.353424658', '0.356164384', '0.35890411', '0.361643836', '0.364383562', '0.367123288', '0.369863014', '0.37260274', '0.375342466', '0.378082192', '0.380821918', '0.383561644', '0.38630137', '0.389041096', '0.391780822', '0.394520548', '0.397260274', '0.4', '0.402739726', '0.405479452', '0.408219178', '0.410958904', '0.41369863', '0.416438356', '0.419178082', '0.421917808', '0.424657534', '0.42739726', '0.430136986', '0.432876712', '0.435616438', '0.438356164', '0.44109589', '0.443835616', '0.446575342', '0.449315068', '0.452054795', '0.454794521', '0.457534247', '0.460273973', '0.463013699', '0.465753425', '0.468493151', '0.471232877', '0.473972603', '0.476712329', '0.479452055', '0.482191781', '0.484931507', '0.487671233', '0.490410959', '0.493150685', '0.495890411', '0.498630137', '0.501369863', '0.504109589', '0.506849315', '0.509589041', '0.512328767', '0.515068493', '0.517808219', '0.520547945', '0.523287671', '0.526027397', '0.528767123', '0.531506849', '0.534246575', '0.536986301', '0.539726027', '0.542465753', '0.545205479', '0.547945205', '0.550684932', '0.553424658', '0.556164384', '0.55890411', '0.561643836', '0.564383562', '0.567123288', '0.569863014', '0.57260274', '0.575342466', '0.578082192', '0.580821918', '0.583561644', '0.58630137', '0.589041096', '0.591780822', '0.594520548', '0.597260274', '0.6', '0.602739726', '0.605479452', '0.608219178', '0.610958904', '0.61369863', '0.616438356', '0.619178082', '0.621917808', '0.624657534', '0.62739726', '0.630136986', '0.632876712', '0.635616438', '0.638356164', '0.64109589', '0.643835616', '0.646575342', '0.649315068', '0.652054795', '0.654794521', '0.657534247', '0.660273973', '0.663013699', '0.665753425', '0.668493151', '0.671232877', '0.673972603', '0.676712329', '0.679452055', '0.682191781', '0.684931507', '0.687671233', '0.690410959', '0.693150685', '0.695890411', '0.698630137', '0.701369863', '0.704109589', '0.706849315', '0.709589041', '0.712328767', '0.715068493', '0.717808219', '0.720547945', '0.723287671', '0.726027397', '0.728767123', '0.731506849', '0.734246575', '0.736986301', '0.739726027', '0.742465753', '0.745205479', '0.747945205', '0.750684932', '0.753424658', '0.756164384', '0.75890411', '0.761643836', '0.764383562', '0.767123288', '0.769863014', '0.77260274', '0.775342466', '0.778082192', '0.780821918', '0.783561644', '0.78630137', '0.789041096', '0.791780822', '0.794520548', '0.797260274', '0.8', '0.802739726', '0.805479452', '0.808219178', '0.810958904', '0.81369863', '0.816438356', '0.819178082', '0.821917808', '0.824657534', '0.82739726', '0.830136986', '0.832876712', '0.835616438', '0.838356164', '0.84109589', '0.843835616', '0.846575342', '0.849315068', '0.852054795', '0.854794521', '0.857534247', '0.860273973', '0.863013699', '0.865753425', '0.868493151', '0.871232877', '0.873972603', '0.876712329', '0.879452055', '0.882191781', '0.884931507', '0.887671233', '0.890410959', '0.893150685', '0.895890411', '0.898630137', '0.901369863', '0.904109589', '0.906849315', '0.909589041', '0.912328767', '0.915068493', '0.917808219', '0.920547945', '0.923287671', '0.926027397', '0.928767123', '0.931506849', '0.934246575', '0.936986301', '0.939726027', '0.942465753', '0.945205479', '0.947945205', '0.950684932', '0.953424658', '0.956164384', '0.95890411', '0.961643836', '0.964383562', '0.967123288', '0.969863014', '0.97260274', '0.975342466', '0.978082192', '0.980821918', '0.983561644', '0.98630137', '0.989041096', '0.991780822', '0.994520548', '0.997260274', '1']


    #put the day for the respective years and days in the year in the list
    a = 0
    b = 0
    single = False
    
    if item == 3:
        field = input('''What field is this for? This options are
        for inorganic Press - 'B'
        for organic press - 'C'
        for organic winter press 'CW'
        for organic January press 'CJ'
        for organic October press 'CO'
        for organic November press 'CN'
        for organic December press 'CD'
        for Palmyra press 'P'
    ''').upper()
        print('\n')
    # pair fix A
    # six year data - Test and trouble shooting data set(6 years)
    # Paired Fix B (Test and trouble shooting)
    
#     Use shit list for trouble shooting it is the most correct list!!!


#     usable_events = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60]
#     events = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60]
#     concentration_pred = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60]
# #     item -= 4
#     item_name = {'here' : 4}
#     print(len(concentration_pred))
# #     print('\n')
# #     takeout1 = [[0, 1, 4], [0, 1, 3], [0, 7, 9], [0, 2, 4], [0], [0, 1, 3], [0, 2, 3]]  #This is the controlling list
# #     years= [        0,         10,         0,       10,     10,     10,        10,]
#     years= [        0,         0,        10,         0,         0,         10,        0,         0,        10,        10,      10]
#     takeout1 = [[0, 2, 4], [0, 5, 7], [0, 0, 4], [0, 5, 7], [0, 8, 9], [0, 0, 3], [0, 4, 6], [0, 7, 9], [0, 3, 6], [0, 0, 3], [0]]
# #     				1		   2          3          4          5          6          7          8          9          10      11

    if field == 'B':
    # inorganic
    # the new P bandwidth list are both years list and the takeout1 list. 
#     # you can use any of the takeouts (takeout1) here, the year number in the beginning of the sublist does not make any sense.
        takeout1 = [[0, 99, 149], [0, 133, 253], [0], [0],[0, 134, 235], [0]]   #This is the controlling list
        years= [         0,           365,       366, 365,    365,       365]



    if field == 'C':
    # organic A (full) - starting 2019

# notice the merging years (2022)
#                  2019           2019          2020R         2020           2020         2021R       2022         2022           2023R         2023         2024R
        years= [        0,             0,           365,          0,             0,           366,        365,           0,           365,         365,         365]
        takeout1 = [[0, 14, 118], [0, 339, 364], [0, 0, 88], [0, 148, 226], [0, 275, 365], [0, 0, 30], [0, 5, 125], [0, 283, 364], [0, 0, 62], [0, 317, 364], [0, 0, 73]]
                    
    if field == 'CW':
    # organic B (winter applications) 
#     
        takeout1 = [[0, 339, 364], [0, 0, 88], [0, 275, 365], [0, 0, 30], [0, 283, 364], [0, 0, 62], [0, 317, 364], [0, 0, 73]]   #This is the controlling list
        years = [        0,           365,          0,           366,         365,          365,         365,          366]

    
    if field == 'CJ':
    ## organic January application
        takeout1 = [[0, 13, 118], [0], [0], [0, 5, 125], [0],[0]]   #This is the controlling list
        years = [       0,        365, 366,    365,      365,365]

    if field == 'CO':
    ## organic October application
        takeout1 = [[0, 275, 365], [0, 0, 30], [0, 283, 364], [0, 0, 62], [0]]    #This is the controlling list
        years = [       365,          366,         365,          365,     365]

    
    if field == 'CN':
    ## organic November application (starting with 3 years without fertilzier application)
        takeout1 = [[0, 317, 364], [0, 0, 73]]
        years = [       1096,          365]    
    
    if field == 'CD':
    ## organic December application
        takeout1 = [[0, 339, 364], [0, 0, 88], [0], [0], [0], [0]]    #This is the controlling list
        years = [        0,           365,     366, 365, 365, 365]

    #     
    #  print(takeout1)
    # takeout1 = [[365, 99, 149]]
    
    if field == 'P':
    # palmyra A (full)
        takeout1 = [[0, 135, 170],[0, 308, 365],[0, 0, 63],[0, 287, 364],[0, 0, 43]]   #This is the controlling list
        years = [        0,           365,         366,        365,         365]
    
             
    takeout = []
    tapper = 1
    once = True
    potential_danger = False
    
    for elements in range(0, len(takeout1)):
        a = 0
        for element in range(0, elements + 1):
            a += years[element]
        if elements <= len(takeout1) and years[element] == 0 and len(takeout) > 0:
            crash = takeout1[int(len(takeout)/2)][1] - takeout1[int(len(takeout)/2) - 1][2]
            if crash < 0:
                print(f'There is a time line error in the takout list. It is between items {int(len(takeout)/2)} and {int(len(takeout)/2)+1} in the list')
                exit()
                
#         print(a)
#         print(b)
#         print(takeout)
        if elements > 0:
            if len(takeout1[elements]) > 1:
                a
                a += takeout1[elements][1]
                dif = takeout1[elements][2] - takeout1[elements][1]
                a
                b
                b = a + dif
                b
                takeout.append(a)
                takeout.append(b)
#                 print(takeout)
        else:
            if len(takeout1[elements]) > 0:
                a
                a += takeout1[elements][1]
                a
                if years[0] > 0 and once:
                    b += years[0]
                    once = False
                b += takeout1[elements][2]
                b
                takeout.append(a)
                takeout.append(b)
#                 print(takeout)
    #         print('\n')



    #     takeout = [1, 4, 12, 14]
    
    print(takeout)
    print('\n')
    takeout
    takeout.append(takeout[len(takeout) - 1] * 10)
    start = 0
    clean = []

    for elements in range(0, len(concentration_pred)):
        if start % 2 == 0:
            if elements < takeout[start]:
    #                 print(concentration_pred[elements])
                clean.append(concentration_pred[elements])
                usable_events.append(events[elements])
            elif elements == takeout[start + 1]:
    #                 print(concentration_pred[elements])
                start += 1
                clean.append(concentration_pred[elements])
                usable_events.append(events[elements])
    #                 
        elif elements >= takeout[start] and elements < takeout[start + 1]:
    #             print(concentration_pred[elements])
            clean.append(concentration_pred[elements])
            usable_events.append(events[elements])
        else:
            start += 1
#     print('\n')
#     print(f'This is your training {item_name}')
#     print(clean)
#     print(len(clean))
#     print('\n')
    
    a = clean
    b = ''
    for elements in range(0, len(a)):
        b += str(a[elements])
        if elements < len(a) - 1:
            b += ', '
#     print(b)
    library.append(b)


#     print('start')
#     for elements in clean:
#         print(elements)
#     print('end')
    print('\n')
    if item == 1 and todo == 'yes':
        print('These are the usable events')
        print('not printed')
#         print(usable_events)
#         print(len(usable_events))
#         print('Paste this event in the txt file name scrapped events. it is the same as usable events')
#     print('\n')
#     print('start')
#     for elements in usable_events:
#         print(elements)
#     print('end')
        
#     print('\n')
#     print('\n')
#     print('\n')
#     print('\n')
#     print('\n')
#     print('\n')
#     print('##########################################################################################################################################################################################################################################################################################################################################################')
#     print('\n')
#     print('\n')
#     print('\n')
#     print('\n')
#     print('\n')
# print(f'This is the total trainer \n')


refined_library = []
refined_library.append(library[1])
refined_library.append(library[2])
refined_library.append(library[3])
refined_library.append(library[0])
# print(refined_library)
# print(len(refined_library))
# print("\n")

numbers = refined_library
file_name = "Training_data_outline_kicker.txt"

# Write to file
with open(file_name, "w") as file:
    for number in numbers:
        file.write(f"{number}\n")

print(f"Numbers successfully written to {file_name}")
















a = open('Training_data_outline_kicker.txt', 'r')

# order in txt
#Load
#flow
#time
#precip

bx = []
# split takes all the individual element and makes them elements of a list while
# strip would divide it by lines and would only start a new list elements when there is a new line / or enter
for lines in a:
    # c = we strip the lines with c, making every line an item
    c = lines.strip()
    # d = lines.split()
    bx.append(c)
a.close()
# print(bx)
# print(len(bx))

# load_final_1 = [0.355, 0.152, 0.154, 0.162, 0.169, 0.148, 0.162, 0.133, 0.117, 0.089, 0.174, 0.255, 0.121, 0.226, 0.067, 0.07, 0.069, 0.055, 0.049, 0.08, 0.061, 0.036, 0.037, 0.056, 0.039, 0.04, 0.032, 0.043, 0.051, 0.035, 0.077, 0.374, 0.188, 0.11, 0.083, 0.074, 0.053, 0.053, 0.052, 0.077, 0.082, 0.043, 0.051, 0.047, 0.228, 0.373, 0.181, 0.133, 0.08, 0.527, 0.584, 0.214, 0.1, 0.087, 0.135, 0.118, 0.172, 0.135, 0.05, 0.073, 0.046, 0.052, 0.042, 0.035, 0.033, 0.056, 0.076, 0.046, 0.083, 0.067, 0.084, 0.232, 0.062, 0.045, 0.044, 0.06, 0.04, 0.059, 0.031, 0.055, 0.058, 0.132, 0.751, 0.093, 0.045, 0.034, 0.36, 0.095, 0.057, 0.043, 0.044, 0.04, 0.036, 0.037, 0.034, 0.047, 0.04, 0.038, 0.033, 0.038, 0.036, 0.035, 0.034, 0.035, 0.038, 0.046, 0.044, 0.059, 0.107, 0.184, 0.05, 0.047, 0.054, 0.059, 0.034, 0.062, 0.039, 0.05, 0.051, 0.143, 0.091, 0.072, 0.058, 0.054, 0.149, 0.131, 0.123, 0.151, 0.128, 0.13, 0.137, 0.206, 0.211, 0.224, 0.103, 0.102, 0.112, 0.057, 0.068, 0.071, 0.088, 0.073, 0.074, 0.146, 0.072, 0.083, 0.199, 0.202, 0.199, 0.201, 0.203, 0.199, 0.179, 0.16, 0.14, 0.121, 0.038, 0.029, 0.047, 0.054, 0.061, 0.051, 0.026, 0.045 ,0.069, 0.066, 0.062, 0.059, 0.056, 0.055, 0.054, 0.052, 0.06, 0.067, 0.625, 0.61, 0.162, 0.103, 0.089, 0.074, 0.06, 0.09, 0.076, 0.059, 0.061, 0.062, 0.063, 0.11, 0.133, 0.093, 0.102, 0.087, 0.084, 0.082, 0.079, 0.077, 0.074, 0.071, 0.067, 0.064, 0.062, 0.061, 0.059, 0.057, 0.07, 0.093, 0.055, 0.051, 0.047, 0.047, 0.048, 0.048, 0.049, 0.049, 0.047, 0.047, 0.047, 0.05, 0.04, 0.049, 0.047, 0.051, 0.126, 0.126, 0.126, 0.099, 0.064, 0.068, 0.061, 0.062, 0.064, 0.066, 0.059, 0.068, 0.092, 0.063, 0.073, 0.061, 0.066, 0.054, 0.06, 0.077, 0.107, 0.049, 0.054, 0.053, 0.098, 0.05, 0.136, 0.124, 0.287, 0.275, 0.134, 0.13, 0.127, 0.125, 0.127, 0.127, 0.135, 0.13, 0.058, 0.257, 0.065, 0.056, 0.061, 0.062, 0.058, 0.058, 0.065, 0.07, 0.041, 0.043, 0.03, 0.032, 0.03, 0.028, 0.029, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.009, 0.01, 0.027, 0.025, 0.023, 0.022, 0.021, 0.021, 0.021, 0.153, 0.069, 0.148, 0.058, 0.035, 0.064, 0.053, 0.036, 0.048, 0.037, 0.029, 0.032, 0.032, 0.004, 0.039, 0.045, 0.065, 0.045, 0.076, 0.04, 0.037, 0.106, 0.087, 0.086, 0.07, 0.068, 0.203, 0.164, 0.125, 0.085, 0.046, 0.046, 0.047, 0.048, 0.06, 0.084, 0.05, 0.051, 0.052, 0.053, 0.054, 0.055, 0.056, 0.057, 0.064, 0.071, 0.078, 0.085, 0.092, 0.099, 0.106, 0.113, 0.08, 0.068, 0.056, 0.055, 0.055, 0.071, 0.133, 0.11, 0.087, 0.064, 0.08, 0.096, 0.112, 0.16, 0.206, 0.184, 0.091, 0.071, 0.066, 0.062, 0.057, 0.056, 0.054, 0.052, 0.059, 0.187, 0.186, 0.235, 0.21, 0.185, 0.191, 0.197, 0.204, 0.198, 0.192, 0.187, 0.175, 0.202, 0.216, 0.213, 0.211, 0.208, 0.205, 0.202, 0.168, 0.19031, 0.13247, 0.11762, 0.085, 0.113, 0.142, 0.082, 0.075, 0.073, 0.072, 0.071, 0.066, 0.061, 0.069, 0.069, 0.076, 0.084, 0.091, 0.098, 0.105, 0.112, 0.119, 0.126, 0.133, 0.126, 0.119, 0.111, 0.104, 0.111, 0.245, 0.102, 0.111, 0.2, 0.327, 0.177, 0.062, 0.058, 0.057, 0.055, 0.064, 0.073, 0.074, 0.074, 0.075, 0.076, 0.076, 0.074, 0.071, 0.068, 0.065, 0.062, 0.059, 0.057, 0.054, 0.004, 0.008, 0.035, 0.062, 0.091, 0.119, 0.148, 0.058, 0.051, 0.06, 0.058, 0.056, 0.054, 0.053, 0.051, 0.049, 0.05, 0.052, 0.053, 0.053, 0.054, 0.056, 0.057, 0.055, 0.052, 0.05, 0.048, 0.048, 0.049, 0.05, 0.05, 0.051, 0.046, 0.047, 0.048, 0.05, 0.052, 0.054, 0.128, 0.318, 0.091]
# print(len(load_final_1))
# print('\n')
# flow_final_1 = [0.033864719, 0.036077713, 0.012012411, 0.00573766, 0.003271581, 0.003176469, 0.002751211, 0.0014542, 0.0077384, 0.010256621, 0.515216161, 0.442206165, 0.136936422, 0.091453236, 0.055196286, 0.040672423, 0.069739385, 0.068038641, 0.091396179, 0.069895901, 0.108447711, 0.159881341, 0.121829051, 0.09325476, 0.071150397, 0.037996151, 0.040669943, 0.033302273, 0.01960535, 0.133478622, 0.233561517, 1.235779119, 0.490172611, 0.22417547, 0.172473509, 0.136268018, 0.10160674, 0.08479144, 0.055057002, 0.037054625, 0.033753684, 0.038464345, 0.029377112, 0.026779319, 0.571827026, 1.52522148, 0.417767644, 0.267220503, 0.212777706, 0.949878779, 1.6944, 0.907414064, 0.289515215, 0.283283306, 1.166869311, 1.175476045, 0.69417927, 0.534955916, 0.289768472, 0.221067081, 0.183196387, 0.313888034, 0.343096143, 0.281941251, 0.229691167, 0.180302999, 0.157566791, 0.138509118, 0.123485874, 0.094839633, 0.081237512, 0.061236205, 0.058706761, 0.059927612, 0.053435771, 0.19309137, 0.185186316, 0.15039184, 0.124538143, 0.109289477, 0.079373968, 0.367997696, 1.112708359, 0.369876309, 0.25990916, 0.204021132, 0.543381721, 0.440940026, 0.274429001, 0.216794546, 0.178100351, 0.149787588, 0.107792379, 0.074206553, 0.051808421, 0.040922746, 0.036584696, 0.037325059, 0.03175321, 0.011838184, 0.003284315, 0.004391962, 0.004491291, 0.004648143, 0.001587081, 7.28e-05, 0.000614, 0.039468068, 0.256673842, 0.816095572, 0.232990532, 0.137567105, 0.090457653, 0.060843848, 0.041636082, 0.031256352, 0.027568486, 0.015697421, 0.009962659, 0.993741557, 0.373858289, 0.112470122, 0.014359717, 0.002837583, 0.030968959, 0.016827352, 0.006428628, 0.004685607, 0.003668451, 0.002009562, 0.001464506, 0.002321243, 7.28e-05, 0.034562501, 0.072929564, 0.153768683, 0.146068788, 0.08295952, 0.067411755, 0.057823575, 0.045124598, 0.04067733, 0.037780671, 0.029671623, 0.024379097, 0.013715526, 0.012093387, 0.012246941, 0.012090689, 0.015003344, 0.012324007, 0.004021272, 0.003977823, 0.003882649, 0.004841493, 0.142753196, 0.099363856, 0.066656315, 0.05565996, 0.049999613, 0.13159236, 0.145518639, 0.079792803, 0.053820109,0.131535421, 0.095992719, 0.075509401, 0.061216245, 0.04981983, 0.040672421, 0.039401446, 0.027074024, 0.028084977, 0.025982222, 1.025219533, 1.56676043, 0.46128328, 0.238574268, 0.153655115, 0.107715474, 0.090947443, 0.191471451, 0.200298135, 0.111366749, 0.08253616, 0.06902673, 0.056500468, 0.311809341, 0.518362458, 0.376876233, 0.367630633, 0.307748253, 0.198831259, 0.144248444, 0.125754868, 0.137148656, 0.117761604, 0.09879106, 0.077952325, 0.068287346, 0.066768976, 0.049442689, 0.034308932, 0.034467237, 0.05617371, 0.184292463, 0.181851477, 0.109618002, 0.072407693, 0.068732721, 0.055566612, 0.045459138, 0.059649317, 0.059415374, 0.048999532, 0.043092596, 0.040839722, 0.037151772, 0.033074731, 0.033286218, 0.038774301, 0.051458827, 0.048438124, 0.035697229, 0.054717363, 0.24807295, 0.13015258, 0.094624441, 0.071008352, 0.052159393, 0.051656538, 0.047833152, 0.046705542, 0.044309588, 0.046506039, 0.036488812, 0.024043002, 0.02435378, 0.033154385, 0.030961446, 0.027319142, 0.153404665, 0.411693182, 0.178795944, 0.126184483, 0.104555615, 0.091472612, 0.081660615, 0.073635818, 0.068510042, 0.787973107, 0.697033506, 0.249798855, 0.1644175, 0.12465517, 0.10289329, 0.089225515, 0.079737325, 0.067058705, 0.063810381, 0.070994886, 0.573834792, 0.242935838, 0.148782999, 0.108458176, 0.093777453, 0.080424703, 0.054103184, 0.05429567, 0.039736082, 0.04678489, 0.074533937, 0.07677363, 0.061964085, 0.05207215, 0.039261697, 0.043099884, 0.03591786, 0.028974859, 0.030140931, 0.021170322, 0.026663259, 0.032506713, 0.025583806, 0.01626298, 0.018546391, 0.015850735, 0.010876381, 0.012891744, 0.011032044, 0.011469789, 0.010008474, 0.00665462, 0.710157554, 0.291397966, 0.219534806, 0.172246558, 0.131480984, 0.090969407, 0.091692493, 0.072512281, 0.052058046, 0.039973934, 0.0277957, 0.019179382, 0.017794346, 0.015544088, 0.015439692, 0.011782376, 0.013254742, 0.009159532, 0.010429144, 0.005542369, 0.00080572, 0.005822797, 0.116953734, 0.205665456, 0.102073731, 0.071253542, 0.600548271, 0.296951747, 0.144466025, 0.125457307, 0.095119563, 0.136575532, 0.1045526, 0.294751036, 0.067406364, 0.058084928, 0.032240706, 0.022112174, 0.014757564, 0.010326566, 0.006665312, 0.004411025, 0.002218308, 0.001014813, 0.001506454, 0.011504518, 0.872100839, 0.28081936, 0.125953145, 0.152217349, 0.637412503, 0.430387103, 0.286327969, 0.20397998, 0.169437213, 0.147799038, 0.126824443, 0.119597449, 0.109758757, 0.076356688, 0.066577735, 0.053934951, 0.03784723, 0.034923701, 0.031514613, 0.02652985, 1.018480923, 0.887127531, 0.35736307, 0.256522144, 0.187261751, 0.14832295, 0.124044622, 0.094237877, 0.086855658, 0.074565231, 0.06031091, 0.000679, 0.003904852, 0.009155564, 0.007809455, 0.005508842, 0.003967742, 0.002523082, 0.002625022, 0.002259268, 0.002090842, 0.0007427, 7.28e-05, 0.003691706, 0.007471293, 0.007658503, 0.003817985, 0.002572733, 0.0009806, 0.0006723, 7.28e-05, 0.321543402, 0.12651244, 0.487196868, 0.184524793, 0.155028906, 1.166195441, 0.319108029, 0.157830518, 0.096904502, 0.06800448, 0.049470336, 0.039081171, 0.032832819, 0.031804465, 0.025989412, 0.026134059, 0.017119014, 0.018488274, 0.021216615, 0.012604551, 0.010172618, 0.011688245, 0.01091363, 0.01208886, 0.011608944, 0.006150984, 0.004373025, 0.003754667, 0.220317062, 0.915226212, 0.223291654, 0.124252262, 0.127559111, 1.167682777, 0.942735821, 0.238645751, 0.137703798, 0.100817234, 0.071201557, 0.057608764, 0.045051554, 0.036587049, 0.038051076, 0.029566644, 0.024942707, 0.018411391, 0.01986963, 0.021842673, 0.026035321, 0.0348261, 0.040742258, 0.08069715, 0.098413731, 0.06626962, 0.065159303, 0.046725914, 0.05031459, 0.041199279, 0.033680081, 0.026294997, 0.473456673, 0.194042548, 0.127628023, 0.102333948, 0.245381761, 0.248883223, 0.160661264, 0.112923871, 0.078270934, 0.063267354, 0.051836952, 0.053650745, 0.055424236, 0.043362439, 0.038072635, 0.039208, 0.04178681, 0.039382642, 0.023106425, 0.02166479, 0.025055595, 0.01813437, 0.01432266, 0.011401091, 0.015152399, 0.013985903, 0.015145911, 0.011993419, 0.013745388, 0.011109125, 0.009010361, 0.009864049, 0.321576533, 1.251031079, 0.261281532]
# print(len(flow_final_1))
# print('\n')
# time_final_1 = [0.005494505494505495, 0.008241758241758242, 0.01098901098901099, 0.013736263736263736, 0.016483516483516484, 0.019230769230769232, 0.02197802197802198, 0.024725274725274724, 0.04395604395604396, 0.046703296703296704, 0.04945054945054945, 0.0521978021978022, 0.054945054945054944, 0.057692307692307696, 0.06043956043956044, 0.06318681318681318, 0.06593406593406594, 0.06868131868131869, 0.07142857142857142, 0.07417582417582418, 0.07692307692307693, 0.07967032967032966, 0.08241758241758242, 0.08516483516483517, 0.08791208791208792, 0.09065934065934066, 0.09340659340659341, 0.09615384615384616, 0.0989010989010989, 0.10164835164835165, 0.1043956043956044, 0.10714285714285714, 0.10989010989010989, 0.11263736263736264, 0.11538461538461539, 0.11813186813186813, 0.12087912087912088, 0.12362637362637363, 0.12637362637362637, 0.12912087912087913, 0.13186813186813187, 0.1346153846153846, 0.13736263736263737, 0.1401098901098901, 0.14285714285714285, 0.14560439560439561, 0.14835164835164835, 0.1510989010989011, 0.15384615384615385, 0.1565934065934066, 0.15934065934065933, 0.1620879120879121, 0.16483516483516483, 0.16758241758241757, 0.17032967032967034, 0.17307692307692307, 0.17582417582417584, 0.17857142857142858, 0.1813186813186813, 0.18406593406593408, 0.18681318681318682, 0.18956043956043955, 0.19230769230769232, 0.19505494505494506, 0.1978021978021978, 0.20054945054945056, 0.2032967032967033, 0.20604395604395603, 0.2087912087912088, 0.21153846153846154, 0.21428571428571427, 0.21703296703296704, 0.21978021978021978, 0.22252747252747251, 0.22527472527472528, 0.22802197802197802, 0.23076923076923078, 0.23351648351648352, 0.23626373626373626, 0.23901098901098902, 0.24175824175824176, 0.2445054945054945, 0.24725274725274726, 0.25, 0.25274725274725274, 0.2554945054945055, 0.25824175824175827, 0.260989010989011, 0.26373626373626374, 0.2664835164835165, 0.2692307692307692, 0.27197802197802196, 0.27472527472527475, 0.2774725274725275, 0.2802197802197802, 0.28296703296703296, 0.2857142857142857, 0.28846153846153844, 0.29120879120879123, 0.29395604395604397, 0.2967032967032967, 0.29945054945054944, 0.3021978021978022, 0.30494505494505497, 0.3076923076923077, 0.3131868131868132, 0.31868131868131866, 0.32142857142857145, 0.3241758241758242, 0.3269230769230769, 0.32967032967032966, 0.3324175824175824, 0.33516483516483514, 0.33791208791208793, 0.34065934065934067, 0.3434065934065934, 0.34615384615384615, 0.3489010989010989, 0.3516483516483517, 0.6456043956043956, 0.6483516483516484, 0.6510989010989011, 0.6538461538461539, 0.6565934065934066, 0.8296703296703297, 0.8324175824175825, 0.8351648351648352, 0.8379120879120879, 0.8406593406593407, 0.8434065934065934, 0.8489010989010989, 0.8901098901098901, 0.8928571428571429, 0.9175824175824175, 0.9203296703296703, 0.9230769230769231, 0.9258241758241759, 0.9285714285714286, 0.9313186813186813, 0.9340659340659341, 0.9368131868131868, 0.9395604395604396, 0.9423076923076923, 0.945054945054945, 0.9478021978021978, 0.9505494505494505, 0.9532967032967034, 0.9560439560439561, 0.9587912087912088, 0.9615384615384616, 0.9642857142857143, 0.967032967032967, 0.9697802197802198, 0.9725274725274725, 0.9752747252747253, 0.978021978021978, 0.9807692307692307, 0.9835164835164835, 0.9862637362637363, 0.989010989010989, 0.9917582417582418, 0.9945054945054945, 0.9972527472527473, 1.0 ,0.0, 0.0027397260273972603, 0.005479452054794521, 0.00821917808219178, 0.010958904109589041, 0.0136986301369863, 0.01643835616438356, 0.019178082191780823, 0.021917808219178082, 0.024657534246575342, 0.0273972602739726, 0.030136986301369864, 0.03287671232876712, 0.03561643835616438, 0.038356164383561646, 0.0410958904109589, 0.043835616438356165, 0.04657534246575343, 0.049315068493150684, 0.052054794520547946, 0.0547945205479452, 0.057534246575342465, 0.06027397260273973, 0.06301369863013699, 0.06575342465753424, 0.0684931506849315, 0.07123287671232877, 0.07397260273972603, 0.07671232876712329, 0.07945205479452055, 0.0821917808219178, 0.08493150684931507, 0.08767123287671233, 0.09041095890410959, 0.09315068493150686, 0.0958904109589041, 0.09863013698630137, 0.10136986301369863, 0.10410958904109589, 0.10684931506849316, 0.1095890410958904, 0.11232876712328767, 0.11506849315068493, 0.1178082191780822, 0.12054794520547946, 0.1232876712328767, 0.12602739726027398, 0.12876712328767123, 0.13150684931506848, 0.13424657534246576, 0.136986301369863, 0.13972602739726028, 0.14246575342465753, 0.14520547945205478, 0.14794520547945206, 0.1506849315068493, 0.15342465753424658, 0.15616438356164383, 0.1589041095890411, 0.16164383561643836, 0.1643835616438356, 0.16986301369863013, 0.1726027397260274, 0.17534246575342466, 0.1780821917808219, 0.18082191780821918, 0.18356164383561643, 0.1863013698630137, 0.18904109589041096, 0.1917808219178082, 0.19452054794520549, 0.19726027397260273, 0.2, 0.20273972602739726, 0.2054794520547945, 0.20821917808219179, 0.21095890410958903, 0.2136986301369863, 0.21643835616438356, 0.2191780821917808, 0.2219178082191781, 0.22465753424657534, 0.2273972602739726, 0.23013698630136986, 0.2328767123287671, 0.2356164383561644, 0.23835616438356164, 0.2410958904109589, 0.24383561643835616, 0.2465753424657534, 0.2493150684931507, 0.25205479452054796, 0.2547945205479452, 0.25753424657534246, 0.2602739726027397, 0.26301369863013696, 0.26575342465753427, 0.2684931506849315, 0.27123287671232876, 0.273972602739726, 0.27671232876712326, 0.27945205479452057, 0.2821917808219178, 0.28493150684931506, 0.2876712328767123, 0.29041095890410956, 0.29315068493150687, 0.2958904109589041, 0.29863013698630136, 0.3013698630136986, 0.3041095890410959, 0.30684931506849317, 0.3095890410958904, 0.31232876712328766, 0.3150684931506849, 0.3178082191780822, 0.32054794520547947, 0.3232876712328767, 0.32602739726027397, 0.3287671232876712, 0.3315068493150685, 0.33424657534246577, 0.336986301369863, 0.33972602739726027, 0.3424657534246575, 0.3452054794520548, 0.34794520547945207, 0.3506849315068493, 0.35342465753424657, 0.0, 0.0027472527472527475, 0.005494505494505495, 0.008241758241758242, 0.01098901098901099, 0.013736263736263736, 0.016483516483516484, 0.019230769230769232, 0.02197802197802198, 0.024725274725274724, 0.027472527472527472, 0.03021978021978022, 0.03296703296703297, 0.03571428571428571, 0.038461538461538464, 0.04120879120879121, 0.04395604395604396, 0.046703296703296704, 0.04945054945054945, 0.0521978021978022, 0.054945054945054944, 0.057692307692307696, 0.06043956043956044, 0.06318681318681318, 0.06593406593406594, 0.06868131868131869, 0.10164835164835165, 0.1043956043956044, 0.10714285714285714, 0.10989010989010989, 0.11263736263736264, 0.11538461538461539, 0.11813186813186813, 0.12087912087912088, 0.15384615384615385, 0.1565934065934066, 0.15934065934065933, 0.1620879120879121, 0.16483516483516483, 0.16758241758241757, 0.17032967032967034, 0.17307692307692307, 0.17582417582417584, 0.17857142857142858, 0.1813186813186813, 0.18406593406593408, 0.18681318681318682, 0.18956043956043955, 0.19230769230769232, 0.19505494505494506, 0.1978021978021978, 0.20054945054945056, 0.2032967032967033, 0.20604395604395603, 0.2087912087912088, 0.21153846153846154, 0.21428571428571427, 0.21703296703296704, 0.21978021978021978, 0.22252747252747251, 0.22527472527472528, 0.22802197802197802, 0.23076923076923078, 0.23351648351648352, 0.23626373626373626, 0.23901098901098902, 0.24175824175824176, 0.2445054945054945, 0.24725274725274726, 0.25, 0.25274725274725274, 0.2554945054945055, 0.25824175824175827, 0.260989010989011, 0.26373626373626374, 0.2664835164835165, 0.2692307692307692, 0.5796703296703297, 0.6510989010989011, 0.6538461538461539, 0.6565934065934066, 0.6593406593406593, 0.6620879120879121, 0.6648351648351648, 0.6675824175824175, 0.6703296703296703, 0.6730769230769231, 0.6758241758241759, 0.6813186813186813, 0.6978021978021978, 0.7005494505494505, 0.7032967032967034, 0.7060439560439561, 0.7087912087912088, 0.7115384615384616, 0.7142857142857143, 0.717032967032967, 0.7417582417582418, 0.7445054945054945, 0.7472527472527473, 0.75, 0.7527472527472527, 0.7554945054945055, 0.7582417582417582, 0.760989010989011, 0.7637362637362637, 0.7664835164835165, 0.7692307692307693, 0.771978021978022, 0.7747252747252747, 0.7774725274725275, 0.7802197802197802, 0.782967032967033, 0.7857142857142857, 0.7884615384615384, 0.7912087912087912, 0.7939560439560439, 0.7967032967032966, 0.7994505494505495, 0.8021978021978022, 0.804945054945055, 0.8076923076923077, 0.8104395604395604, 0.8131868131868132, 0.8159340659340659, 0.8186813186813187, 0.8214285714285714, 0.8241758241758241, 0.8269230769230769, 0.8296703296703297, 0.8324175824175825, 0.8351648351648352, 0.8379120879120879, 0.8406593406593407, 0.8434065934065934, 0.8461538461538461, 0.8489010989010989, 0.8516483516483516, 0.8543956043956044, 0.8571428571428571, 0.8598901098901099, 0.8626373626373627, 0.8653846153846154, 0.8681318681318682, 0.8708791208791209, 0.8736263736263736, 0.8763736263736264, 0.8791208791208791, 0.8818681318681318, 0.8846153846153846, 0.8873626373626373, 0.8901098901098901, 0.8928571428571429, 0.8956043956043956, 0.8983516483516484, 0.9010989010989011, 0.9038461538461539, 0.9065934065934066, 0.9093406593406593, 0.9120879120879121, 0.9148351648351648, 0.9175824175824175, 0.9203296703296703, 0.9230769230769231, 0.9258241758241759, 0.9285714285714286, 0.9313186813186813, 0.9340659340659341, 0.9368131868131868, 0.9395604395604396, 0.9423076923076923, 0.945054945054945, 0.9478021978021978, 0.9505494505494505, 0.9532967032967034, 0.9560439560439561, 0.9587912087912088, 0.9615384615384616, 0.9642857142857143, 0.967032967032967, 0.9697802197802198, 0.9725274725274725, 0.9752747252747253, 0.978021978021978, 0.9807692307692307, 0.9835164835164835, 0.9862637362637363, 0.989010989010989, 0.9917582417582418, 0.9945054945054945, 0.9972527472527473, 1.0]
# print(len(time_final_1))
# print('\n')
# [97, 145]

loop = 0
while loop <= 3:
    b = []
    new_a = ''
    loop += 1
    if loop == 1:
        # a = input('Input the load list: ')
        a = bx[0]
    elif loop == 2:
        # a = input('Input the Drainage Discharge list: ')
        a = bx[1]
    elif loop == 3:
        # a = input('Input the Time Fractions: ')
        a = bx[2]
    else:
        # a = input('Input the window of the new P regime: ')
        a = bx[3]
    for elements in range(0, len(a)):
        if elements + 1 <= len(a) - 1:
            c = ''
            shift = 1
            locked = True
            first_pick = True
            while locked:
                if elements <= 1:
                    if a[elements] != '[' and a[elements] != ']' and a[elements] != ',':
                        if first_pick:
                            c += a[elements]
                            first_pick = False
                        if elements + shift <= len(a) - 1:
                            if a[elements + shift] != ',' and a[elements + shift] != ']':
                                c += a[elements + shift]
                                shift += 1
                            else:
                                b.append(c)
                                locked = False
                        else:
                            b.append(c)
                            locked = False
                    else:
                        locked = False
                elif a[elements - 1] == ',':
                    if a[elements] != '[' and a[elements] != ']' and a[elements] != ',':
                        if first_pick:
                            c += a[elements]
                            first_pick = False
                        if elements + shift <= len(a) - 1:
                            if a[elements + shift] != ',' and a[elements + shift] != ']':
                                c += a[elements + shift]
                                shift += 1
                            else:
                                b.append(c)
                                locked = False
                        else:
                            b.append(c)
                            locked = False
                    else:
                        locked = False
                else:
                    locked = False
    
#                 print('Emeke this is the fixing juncture')
#                 print(b)
#                 print('\n')
    for elements in range(0, len(b)):
        repost = ''
        for element in b[elements]:
            if element != '"' and element != '\'':
                repost += element
        b[elements] = repost

    b.remove(b[1])
    if loop == 1:
        load_final_1 = []
        for elements in range(0, len(b)):
            y = float(b[elements])
            load_final_1.append(y)

    elif loop == 2:
        flow_final_1 = []
        for elements in range(0, len(b)):
            y = float(b[elements])
            flow_final_1.append(y)

    elif loop == 3:
        time_final_1 = []
        for elements in range(0, len(b)):
            y = float(b[elements])
            time_final_1.append(y)

    else:
        precip_final_1 = []
        for elements in range(0, len(b)):
            y = float(b[elements])
            precip_final_1.append(y)
            
# print('Final load full data')
# print(load_final_1)
# print(len(load_final_1))
# print(type(load_final_1))
# print('\n')
# print('Final_Flow_full_data')
# print(flow_final_1)
# print(len(flow_final_1))
# print(type(flow_final_1))
# print('\n')
# print('Final_time full data')
# print(time_final_1)
# print(len(time_final_1))
# print(type(time_final_1))
# print('\n')
# print('Final_precip full data')
# print(precip_final_1)
# print(len(precip_final_1))
# print(type(precip_final_1))
# print('\n')

numbers = []

data = load_final_1

kickout = []
for elements in data:
    kickout.append(float(elements))

x = []
for elements in range (0, len(data)):
    x.append(elements)
    
y1 = data
y2 = flow_final_1

# Create a figure and primary axis
fig, ax1 = plt.subplots(figsize=(8, 5))

# Plot y1 on primary y-axis
ax1.plot(x, y1, 'b-o', label='Trend 1 (y1)')
ax1.set_xlabel('X Axis')
ax1.set_ylabel('Trend 1 (y1)', color='b')
ax1.tick_params(axis='y', labelcolor='b')

# Create secondary y-axis (inverted)
ax2 = ax1.twinx()
ax2.plot(x, y2, 'g--s', label='Trend 2 (y2)', alpha=0.7)
ax2.set_ylabel('Trend 2 (y2)', color='g')
ax2.tick_params(axis='y', labelcolor='g')
ax2.invert_yaxis()  # Invert secondary y-axis

# Title and layout
plt.title('Trend Comparison: Primary vs Inverted Secondary Y-Axis')
fig.tight_layout()
plt.grid(True)

# Show the plot
plt.show()


#the culprit is the data you want to kick out from the kickout list
mark = input('What is the outlier start point:  ')

culprit = float(mark)
i_caught = []
for element in range(0, len(kickout)):
    if kickout[element] > culprit:
        print(element)
        print(kickout[element])
        print('\n')
        i_caught.append(element)

print('\n')
remove_here = kickout
# print(remove_here)

print('\n')
for elements in i_caught:
    remove_here[elements] = 0
    
y1 = remove_here
y2 = flow_final_1

# Create a figure and primary axis
fig, ax1 = plt.subplots(figsize=(8, 5))

# Plot y1 on primary y-axis
ax1.plot(x, y1, 'b-o', label='Trend 1 (y1)')
ax1.set_xlabel('X Axis')
ax1.set_ylabel('Trend 1 (y1)', color='b')
ax1.tick_params(axis='y', labelcolor='b')

# Create secondary y-axis (inverted)
ax2 = ax1.twinx()
ax2.plot(x, y2, 'g--s', label='Trend 2 (y2)', alpha=0.7)
ax2.set_ylabel('Trend 2 (y2)', color='g')
ax2.tick_params(axis='y', labelcolor='g')
ax2.invert_yaxis()  # Invert secondary y-axis

# Title and layout
plt.title('Trend Comparison: Primary vs Inverted Secondary Y-Axis')
fig.tight_layout()
plt.grid(True)

# Show the plot
plt.show()


print(remove_here)
print(len(remove_here))
print(i_caught)
print('\n')
print('This list just above has been cleaned of the outlier')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')

numbers.append(remove_here)
# 
second = flow_final_1
for elements in i_caught:
    second[elements] = 0

print('This is the refined flow')
print(second)
print(len(second))
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
#

numbers.append(second)
fourth = precip_final_1
# 
for elements in i_caught:
    fourth[elements] = 0

print('This is the refined precipition')
print(fourth)
print(len(fourth))

print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')
print('\n')

numbers.append(fourth)
# 
third = time_final_1
# 
for elements in i_caught:
    third[elements] = 0

print('This is the refined time')
print(third)
print(len(third))

numbers.append(third)

file_name = "Random_selector.txt"

# Write to file
with open(file_name, "w") as file:
    for number in numbers:
        file.write(f"{number}\n")

print(f"Numbers successfully written to {file_name}")























#  This code aims to get a randome 20% of the data for testing and validating the data set. 
print('''
This data in the text file should be in the order
load
flow
precipitation
testing_time
''')
import random
import math

#The order of the data in the Random_selector.txt file is
#load
#flow
#precipitation
#testing_time

a = open('Random_selector.txt', 'r')
load1 = ''
load = []
flow1 = ''
flow = []
precipitation1 = ''
precipitation = []
testing_time1 = ''
testing_time = []
cycler = 0
data_pile = []
for lines in a:
    cycler += 1
    if cycler == 1:
        load1 += lines
        data_pile.append(load1)
    elif cycler == 2:
        flow1 += lines
        data_pile.append(flow1)
    elif cycler == 3:
        precipitation1 += lines
        data_pile.append(precipitation1)
    else:
        testing_time1 += lines
        data_pile.append(testing_time1)
#     print(lines)

for elementt in range(0, 4):
    a = data_pile[elementt]
    new_a = ''
    b = []
    for elements in range(0, len(a)):
        if elements + 1 <= len(a) - 1:
            c = ''
            shift = 1
            locked = True
            first_pick = True
            while locked:
                if elements <= 1:
                    if a[elements] != '[' and a[elements] != ']' and a[elements] != ',':
                        if first_pick:
                            c += a[elements]
                            first_pick = False
                        if elements + shift <= len(a) - 1:
                            if a[elements + shift] != ',' and a[elements + shift] != ']':
                                c += a[elements + shift]
                                shift += 1
                            else:
                                b.append(c)
                                locked = False
                        else:
                            b.append(c)
                            locked = False
                    else:
                        locked = False
                elif a[elements - 1] == ',':
                    if a[elements] != '[' and a[elements] != ']' and a[elements] != ',':
                        if first_pick:
                            c += a[elements]
                            first_pick = False
                        if elements + shift <= len(a) - 1:
                            if a[elements + shift] != ',' and a[elements + shift] != ']':
                                c += a[elements + shift]
                                shift += 1
                            else:
                                b.append(c)
                                locked = False
                        else:
                            b.append(c)
                            locked = False
                    else:
                        locked = False
                else:
                    locked = False
    # print(b)
    # print(len(b))
    # print(type(b))

    for elements in range(0, len(b)):
        repost = ''
        for element in b[elements]:
            if element != '"' and element != '\'':
                repost += element
        b[elements] = repost

#     print(b)
#     print(len(b))
#     print(type(b))
#     print('\n')
    for elementy in range(0, len(b)):
        if elementt == 0:
            load.append(b[elementy])
        elif elementt == 1:
            flow.append(b[elementy])
        elif elementt == 2:
            precipitation.append(b[elementy])
        else:
            testing_time.append(b[elementy])

print(len(load))
print(len(flow))
print(len(precipitation))
print(len(testing_time))
random_pick = []
# here I am going off 20% of the data for the validation
y = math.ceil(0.2 * len(load))
print(y)
print('\n')
# for elements in range(0, y):
while len(random_pick) < y:
    a = random.randint(1,len(load)-1)
    if len(random_pick) > 0:
        match = 0
        for elements in random_pick:
            if a == elements:
                match += 1
        if match == 0:
            random_pick.append(a)
    else:
        random_pick.append(a)
print(random_pick)
print('\n')
random_pick.sort()

# The original list is now sorted
print('This is the random sorted pick')
print(random_pick)
print(len(random_pick))
print('\n')

a = random_pick
length = len(a)

shift = 0
shat = 10000
gap_sum = 0
length = 0
for elements in range(1, len(a)):
    gap = a[elements] - a[elements - 1]
    gap_sum += gap
    length += 1
    if gap > shift:
        high_shift = gap
        max_gap = high_shift
        low_up = a[elements - 1]
        high_up = a[elements]        
#         print(low_up)
#         print(high_up)
#         print(max_gap)
#         print('\n')
        shift = gap
    if gap < shat:
        low_shift = gap
        upper_low = a[elements]
        lower_low = a[elements - 1]
        shat = gap
# y = math.fsum(a)

print(f'max pick - {a[length]}')
print(f'min pick - {a[0]}')
print('\n')
mean = gap_sum/length
print('Largest Span ends')
print(low_up)
print(high_up)
print(max_gap)
print('\n')
print('Lowest span ends')
print(lower_low)
print(upper_low)
print(shat)
print('\n')
print('maximum gap')
print(high_shift)
print('\n')
print('minimum gap')
print(low_shift)
print('\n')
print('mean')
print(mean)
print('\n')

testing_load = []
testing_flow = []
testing_precipitation = []
year_testing_time = []
for element in random_pick:
    testing_load.append(float(load[element]))
    load[element] = 0
    testing_flow.append(float(flow[element]))
    flow[element] = 0
    testing_precipitation.append(float(precipitation[element]))
    year_testing_time.append(float(testing_time[element]))
    testing_time[element] = 0
    
#     This is solely for debugging the code
# testing_load = [' 1.6e-05', ' 7.67e-06', ' 2.26e-06', ' 0.0', ' 0.0', ' 0.0', ' 0.000765691', ' 0.000132216', ' 0.0', ' 0.0', ' 0.0', ' 8.15e-05', ' 4.68e-06', ' 0.000104', ' 8.3e-05', ' 7.49e-05', ' 3.47e-05', ' 2.01e-05', ' 0.002258794', ' 2.82e-05', ' 5.25e-06', ' 3.41e-06', ' 0.00118', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 9.06e-05', ' 3.44e-05', ' 3.73e-05', ' 7.78e-07', ' 3.36e-05', ' 0.0', ' 0.0', ' 0.0', ' 7.79e-05', ' 9.19e-05', ' 5.6e-05', ' 0.000426331', ' 0.000309', ' 0.000183', ' 0.00014', ' 7.76e-05', ' 9.82e-05', ' 9.28e-05', ' 7.92e-05', ' 2.93e-05', ' 1.44e-05', ' 9.62e-06', ' 0.000155814', ' 0.001676765', ' 0.000438583', ' 0.001176786', ' 0.000404357', ' 0.000197619', ' 8.74e-05', ' 0.000128241', ' 8.23e-05', ' 8.32e-05', ' 0.000105788', ' 9.93e-05', ' 5.73e-05', ' 2.55e-05', ' 8.15e-05', ' 8.83e-05', ' 0.000128696', ' 9.39e-05', ' 1.74e-05', ' 1.88e-05', ' 1.56e-05', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.00108104', ' 0.000437139', ' 9.72e-05', ' 8.04e-05', ' 4.73e-05', ' 0.0', ' 2.17e-06', ' 1.56e-06', ' 0.002281879', ' 0.000429015', ' 7.8e-05', ' 0.000124593', ' 0.000102237', ' 1.25e-05', ' 7.29e-06', ' 4.27e-06', ' 7.75e-06', ' 0.000252357', ' 0.001392094', ' 3.03e-05', ' 4.2e-05', ' 1.42e-05', ' 0.000126335', ' 0.0', ' 6.73e-05', ' 0.000282031', ' 0.000702481', ' 0.017555811', ' 0.00030493', ' 0.001835104', ' 2.86e-06', ' 3.68e-06', ' 8.26e-05', ' 0.00450964', ' 0.000444907', ' 0.000274155', ' 0.000669547', ' 0.003538716', ' 1.22e-05', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 7.48e-06', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.010065535', ' 4.51e-05', ' 0.001176', ' 0.000367358', ' 0.00023259', ' 0.009287932', ' 0.000465288', ' 0.000301757', ' 0.01680808', ' 0.000179609', ' 4.29e-05', ' 4.68e-05', ' 3.85e-05', ' 7.09e-05', ' 0.000736785', ' 0.000601962', ' 0.001544016', ' 0.000382796', ' 0.000368483', ' 0.002672583', ' 0.001132252', ' 0.000503356', ' 0.000309502', ' 0.000130193', ' 6.62e-05', ' 8.72e-05', ' 7.81e-06', ' 0.0', ' 9.74e-06', ' 1.19e-05', ' 7.81e-06', ' 0.0', ' 0.005060108', ' 0.001588569', ' 0.001473186', ' 0.000691529', ' 0.000325706', ' 0.000890809', ' 0.0', ' 0.0', ' 0.0', ' 0.000189077', ' 0.000377551', ' 0.000431112', ' 0.000372377', ' 0.000202635', ' 0.000256882', ' 0.000216312', ' 6.44e-05', ' 9.95e-05', ' 0.000320356', ' 0.003418077', ' 0.002861756', ' 0.000171096', ' 6.76e-05', ' 0.000234014', ' 0.000222742', ' 0.000155177', ' 4.99e-05', ' 0.000959625', ' 0.000162954', ' 6.14e-05', ' 9.82e-05', ' 5.57e-05', ' 0.0', ' 7.14e-05', ' 4.24e-05', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 4.36e-05', ' 1.27e-05', ' 5.44e-05', ' 0.000115166', ' 0.000565886', ' 0.000244115', ' 0.000177614', ' 0.011494069', ' 0.002730112', ' 0.000844359', ' 0.00085541', ' 0.000411091', ' 0.000184339', ' 0.000416854', ' 0.000236058', ' 0.000114747', ' 0.00010145', ' 3.35e-05', ' 1.26e-05', ' 0.001492816', ' 5.24e-06', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.000347534', ' 5.34e-05', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.00027686', ' 0.000234417', ' 6.26e-05', ' 0.000169374', ' 5.58e-05', ' 1.47e-05', ' 0.000850007', ' 0.004862944', ' 0.003029208', ' 0.000207775', ' 8.58e-05', ' 7.84e-05', ' 6.12e-05', ' 0.000105909', ' 0.000115715', ' 0.000117167', ' 8.42e-05', ' 0.003975247', ' 0.000356189', ' 4.46e-05', ' 4.8e-05', ' 2.9e-05', ' 0.001457057', ' 0.001253492', ' 0.000199267', ' 5.44e-05', ' 1.98e-05', ' 3.91e-06', ' 4.78e-06', ' 0.000138786', ' 0.000469', ' 0.000323', ' 0.000245', ' 0.000365', ' 0.00316', ' 0.0028', ' 0.000377', ' 0.00017', ' 2.74e-05', ' 0.000146777', ' 0.0', ' 0.0', ' 0.006373756', ' 0.000915648', ' 1.56e-05', ' 0.0', ' 1.46e-06', ' 4.15e-06', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0', ' 0.0']
# random_pick = [9, 11, 20, 26, 27, 34, 40, 41, 47, 48, 55, 59, 65, 83, 84, 92, 96, 112, 120, 124, 129, 131, 137, 148, 151, 164, 174, 176, 179, 180, 189, 192, 193, 198, 208, 212, 217, 219, 237, 238, 239, 256, 257, 259, 262, 281, 284, 287, 291, 301, 309, 310, 317, 327, 329, 341, 344, 351, 371, 380, 381, 383, 384, 385, 387, 411, 422, 424, 428, 434, 443, 445, 446, 450, 451, 459, 468, 470, 476, 479, 485, 486, 487, 498, 504, 513, 514, 516, 520, 522, 531, 542, 545, 552, 553, 555, 558, 569, 570, 572, 573, 576, 577, 581, 588, 590, 591, 599, 610, 616, 622, 625, 626, 637, 639, 641, 644, 647, 650, 656, 660, 669, 673, 675, 678, 681, 688, 689, 693, 695, 702, 709, 713, 719, 729, 731, 732, 739, 742, 751, 752, 754, 758, 760, 761, 765, 767, 771, 773, 777, 779, 781, 783, 784, 786, 791, 792, 794, 797, 804, 815, 824, 826, 832, 838, 840, 846, 848, 852, 856, 859, 868, 877, 878, 879, 884, 909, 910, 912, 916, 920, 923, 924, 928, 930, 933, 936, 937, 948, 956, 957, 963, 967, 970, 974, 975, 992, 994, 997, 1003, 1007, 1009, 1012, 1018, 1021, 1023, 1024, 1027, 1034, 1041, 1042, 1043, 1047, 1048, 1049, 1054, 1056, 1065, 1066, 1068, 1081, 1085, 1086, 1093, 1100, 1107, 1116, 1125, 1128, 1136, 1138, 1145, 1147, 1148, 1149, 1153, 1157, 1158, 1168, 1170, 1176, 1183, 1185, 1188, 1194, 1200, 1203, 1208, 1210, 1232, 1239, 1244, 1246, 1251, 1258, 1261, 1262, 1264, 1268, 1272, 1276, 1296, 1300, 1307, 1324, 1333, 1336, 1337, 1344, 1345, 1360, 1362, 1364, 1371, 1375, 1379, 1394, 1396, 1398, 1402, 1426, 1429, 1437, 1442, 1453, 1457, 1459, 1466, 1471, 1474, 1487, 1489, 1492, 1495, 1503, 1504, 1509, 1512, 1519, 1520, 1529, 1530, 1536, 1548, 1560, 1562, 1569, 1583, 1584, 1593, 1596, 1612, 1613, 1618, 1619, 1620, 1627, 1628, 1633, 1635, 1636, 1638, 1649, 1651, 1660, 1662, 1669, 1671, 1672, 1679, 1687, 1689, 1690, 1696, 1702, 1704, 1708, 1716, 1724, 1732, 1743, 1745, 1746, 1747, 1750, 1760, 1770, 1776, 1781, 1787, 1789, 1792, 1796, 1797, 1801, 1811, 1812, 1824, 1827, 1830, 1835, 1837, 1842, 1843, 1848, 1854, 1867, 1873, 1874, 1877, 1878, 1881, 1882, 1883, 1884, 1886, 1888, 1892, 1893, 1895, 1898, 1905, 1906, 1913, 1919]

print('testing Load')
print(testing_load)
print(len(testing_load))

print('\n')
zero_fraction = 0
for elements in testing_load:
    if float(elements) == 0:
        zero_fraction += 1

print('The fraction of zero or percentage of zero in this list is')
print('This is for the test  not the training')
zero_percent = zero_fraction/len(random_pick)
print(zero_percent)
print('\n')
print('\n')
# for elements in testing_load:
#     print(elements)
# print('\n')


while len(testing_load) < 365:
    testing_load.append(0)

sizing = len(testing_load)
useful = True
change = False
if sizing > 365:
    bag = 0
    for elements in range (365, sizing):
        bag += float(testing_load[elements])
    if bag == 0:
        useful = False
        print('No use outside year limit')
        print('\n')
    else:
        change = True
        change_box = []
        for elements in range (0, sizing):
            y = testing_load[elements]
            if float(y) == 0:
                change_box.append(elements)
#         print('Change_box')
#         print(change_box)
    if change == True:
        testing_load = [item for item in testing_load if float(item) != float(0)]
#     print(testing_load)
        
        
if useful == False:
    while len(testing_load) > 365:
        testing_load.remove(testing_load[len(testing_load) - 1])
elif change == True:
    while len(testing_load) < 365:
        testing_load.append(0)
    
    print('These are the pick outs')
    print(change_box)
    print(len(change_box))
    print('\n')

print('This is the testing load')
print(testing_load)
print(len(testing_load))
print('\n')
        
numbers = testing_load
with open("year_load_fet.txt", "w") as file:
    file.write("\n".join(map(str, numbers)))
    
print('######################################################################################################################################')

while len(testing_flow) < 365:
    testing_flow.append(0)

if useful == False:
    while len(testing_flow) > 365:
        testing_flow.remove(testing_flow[len(testing_flow) - 1])
    
if change == True:
    for elements in change_box:
        testing_flow[elements] = 'a'
    testing_flow = [item for item in testing_flow if item != 'a']
    

    while len(testing_flow) < 365:
        testing_flow.append(0)

print('Testing flow')
print(testing_flow)
print(len(testing_flow))
print('\n')
# print('testing Drainage Discharge')
# 
# for elements in testing_flow:
#     print(elements)
# print('\n')

numbers = testing_flow
with open("year_drainage_discharge_fet.txt", "w") as file:
    file.write("\n".join(map(str, numbers)))
    
print('######################################################################################################################################')

while len(testing_precipitation) < 365:
    testing_precipitation.append(0)

if useful == False:
    while len(testing_precipitation) > 365:
        testing_precipitation.remove(testing_precipitation[len(testing_precipitation) - 1])

if change == True:
    for elements in change_box:
        testing_precipitation[elements] = 'a'
    testing_precipitation = [item for item in testing_precipitation if item != 'a']
    

    while len(testing_precipitation) < 365:
        testing_precipitation.append(0)

print('Testing precipitation')
print(testing_precipitation)
print(len(testing_precipitation))
print('\n')
# print('testing precipitation')
# 
# for elements in testing_precipitation:
#     print(elements)
# print('\n')

numbers = testing_precipitation
with open("year_precipitation_fet.txt", "w") as file:
    file.write("\n".join(map(str, numbers)))
    
print('######################################################################################################################################')

while len(year_testing_time) < 365:
    year_testing_time.append(0)
    
if useful == False:
    while len(year_testing_time) > 365:
        year_testing_time.remove(year_testing_time[len(year_testing_time) - 1])
    
if change == True:
    for elements in change_box:
        year_testing_time[elements] = 'a'
    year_testing_time = [item for item in year_testing_time if item != 'a']
    

    while len(year_testing_time) < 365:
        year_testing_time.append(0)

print('Testing time')
print(year_testing_time)
print(len(year_testing_time))
print('\n')
# print('testing Time')
# 
# for elements in year_testing_time:
#     print(elements)
# print('\n')

numbers = year_testing_time
with open("valid_specific_time.txt", "w") as file:
    file.write("\n".join(map(str, numbers)))
    
print('######################################################################################################################################')
print('Training Load')
print(load)
print(len(load))
print('\n')
print('######################################################################################################################################')
print('Training Flow')
print(flow)
print(len(flow))
print('\n')
print('######################################################################################################################################')
print('Precipitation')
print(precipitation)
print(len(precipitation))
print('\n')
print('######################################################################################################################################')
print('Training time')
print(testing_time)
print(len(testing_time))
print('\n')
field = input('''What field and nutrient is this:
example: organic DRP
''')
with open('Training_Simulated_data.txt', 'w') as file:
    file.write(f'''## The order of the data is Load, drainage discharge, time fraction, and active P days. {field} - this is  {field} 6 year 
{load}
{flow}
{testing_time}
[0, 364]
''')
    
print('''
Note: The data set has automatically be written into the
year_load_fet.txt
year_drainage_fet.txt
year_precipitation_fet.txt
valid_specific_time.txt
training_simulated_data.txt
''')






























# valid specific time. txt

# year_load_fet.txt

# year_drainage_discharge_fet.txt 

# year_precipitation_fet.txt

# main data response.txt

# Training_Simulated_data.txt

# Training Data.txt

# load_conc.txt 

# flow_time_load_conc.txt

# load_predictor.txt (you do not need to open this)

# Predicted_training_load.txt (you would not be needing,this, it is an automatic write-up)

# predicted_training_flow_time_load.txt (you do not need to open this) 

# predicted_training_flow_load.txt (you do not need to open this) 

# load_predictor1.txt (you do not need to open this) 

# load_predictor2.txt (you do not need to open this)

# load_conc.txt (you put load and conc respectively here for training)

# load_predictor.txt ( you do not need to open this it is auto updated)

# flow_time_load_conc.txt (add a comma after ever sequential list

# load_predictor1.txt (The order of loading the file below is Flow, Time and Load (respectively) all vertical) - the load is not important in this case it will be replaced you can put anything in there 

# load_predictor2.txt ( flow and load all vertical respectively) - load can be zero as we  use a replacement load


print('''
# The response 1 (also known as thonny response) need the data to be converted to log before it goes in to the analysis

# The response 2 (also known as Pycharm response) need the data to go in - in its pure form without the log conversion

# valid specific time - (you would need this is you are not predicting from January 1st) - put is the time fraction of the period you are trying to predict - should be void of zero and white spaces and length = length of year

# year_load_fet.txt - if not predicting new and old P you don't need to open this - however ensure, it is the same length as other _fet files so the code works

# year_drainage_discharge_fet.txt  - should be void of zero and white spaces and length = length of year

# year_precipitation_fet.txt - if not predicting new and old there is no need to pen this - however ensure, it is the same length as other _fet files so the code works

# Training_Simulated_data.txt - This has load flow time in the corresponding pairs

# main data response.txt

# Training Data.txt
''')

store_input = []

calibration = input('''Is this for calibrating?
if Yes - Input Y
if No - Input N
''').lower()
store_input.append(calibration)

if calibration == 'y':
    a = open('valid_specific_time.txt', 'r')
    specific_time1 = []
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #         c = lines.strip()
        d = lines.split()
        specific_time1.append(d)
    a.close()
    specific_time = []
    for elements in specific_time1:
        specific_time.append(float(elements[0]))
#     print(specific_time)
#     print(len(specific_time))
#     print('\n')
old_P_takeover = 0
thonny = input('''Is this a machine learning model run:
for machine learning press - Y
else press N
''').lower()
store_input.append(thonny)
if thonny == 'y':
    thonny = 'n'
elif thonny == 'n':
    thonny = 't'
else:
    print("wrong input")
    exit()
if thonny == 'n':
    sklearn = 'useful'
    from sklearn.linear_model import LinearRegression
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import mean_squared_error


def grab_data():
    used_frame = 0
    print('\n')
    enough_precip = float(input('what is your precipitation Cutoff: '))
    store_input.append(enough_precip)
    enough_days = int(input('what is your day span Cutoff: '))
    store_input.append(enough_days)
    a = open('year_load_fet.txt', 'r')
    load1 = []
    flow1 = []
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #         c = lines.strip()
        d = lines.split()
        load1.append(d)
    a.close()
    load = []
    for elements in load1:
        if len(elements) == 0:
            load.append(0)
        else:
            load.append(elements[0])
    #     print(load)
    #     print(len(load))
    #     print('\n')
    a = open('year_drainage_discharge_fet.txt', 'r')
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #         c = lines.strip()
        d = lines.split()
        flow1.append(d)
    a.close()
    flow = []
    for elements in flow1:
        if len(elements) == 0:
            flow.append(0)
        else:
            flow.append(elements[0])
    #     print(flow)
    #     print(len(flow))
    #     print('\n')
    a = open('year_precipitation_fet.txt', 'r')
    precipitation1 = []
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #         c = lines.strip()
        d = lines.split()
        precipitation1.append(d)
    a.close()
    precipitation = []
    for elements in precipitation1:
        if len(elements) == 0:
            precipitation.append(0)
        else:
            precipitation.append(elements[0])
    #     print(precipitation)
    #     print('\n')

    remnant = input('''Do you have remnants high New P days from the previous years:
input Y for yes
input N for n
''').lower()
    store_input.append(remnant)
    print('\n')
    #     I will code for the effect of the remnants here
    remnant_list = [0]
    if remnant == 'y':
        water_cutoff1 = input('''Did you consider precipitation cut-off in the previous year
press Y for Yes
Press N for No
''').lower()
        store_input.append(water_cutoff1)
        print('\n')
        day_cutoff1 = input('''Did you consider date cut-off in the previous year
press Y for Yes
press N for no
''').lower()
        store_input.append(day_cutoff1)
        print('\n')
        if water_cutoff1 == 'y' and day_cutoff1 == 'y':
            flow_remnant = float(input('how much flow is left from the previous year: '))
            store_input.append(flow_remnant)
            print('\n')
            day_remnant = int(input('how many days are left from the previous year: '))
            store_input.append(day_remnant)
            print('\n')

            #         This takes out the remnant from the following year

            print('P applicaition dates')
            print(remnant_list)
            print('\n')
            preci_start = remnant_list[0]
            preci_vol = 0
            day_count = 0
            new_p_end = 0
            #         print(f'New P takes over on the {high_new_p_days[0]} day')
            reloop = len(remnant_list)
            preci_25_or_120days = 0
            while reloop > 0:
                for elements in range(preci_start, day_remnant + 1):
                    if new_p_end == 0:
                        preci_vol += float(precipitation[elements])
                        day_count += 1
                    if preci_vol >= flow_remnant and new_p_end == 0 or elements == day_remnant and new_p_end == 0:
                        preci_25_or_120days = elements
                        remnant_list.append(preci_25_or_120days)
                        old_P_takeover = preci_vol
                        print(preci_25_or_120days)
                        new_p_end += 1
                    else:
                        if elements == day_remnant + 1 and new_p_end == 0:
                            preci_25_or_120days = elements
                            old_P_takeover = preci_vol
                            print(preci_25_or_120days)
                            remnant_list.append(preci_25_or_120days)
                            new_p_end += 1
                            next_year_remender = enough_days - (elements - preci_start)
                            reminanat_preci = enough_precip - preci_vol
                print(f'old_P_takeover = {old_P_takeover}')
                #                     cover += 1
                #                     border += 1
                reloop -= 1
                new_p_end = 0
                print('This is the old_year remnant')
                print(remnant_list)
                print('\n')

        elif water_cutoff1 == 'y' and day_cutoff1 == 'n':
            flow_remnant = float(input('how much flow is left from the previous year: '))
            store_input.append(flow_remnant)
            print('\n')

            #         This takes out the remnant from the following year

            print('P applicaition dates')
            print(remnant_list)
            print('\n')
            preci_start = remnant_list[0]
            preci_vol = 0
            day_count = 0
            new_p_end = 0
            #         print(f'New P takes over on the {high_new_p_days[0]} day')
            reloop = len(remnant_list)
            preci_25_or_120days = 0
            while reloop > 0:
                for elements in range(preci_start, len(precipitation)):
                    if new_p_end == 0:
                        preci_vol += float(precipitation[elements])
                        day_count += 1
                    if preci_vol >= flow_remnant and new_p_end == 0:
                        preci_25_or_120days = elements
                        remnant_list.append(preci_25_or_120days)
                        old_P_takeover = preci_vol
                        print(preci_25_or_120days)
                        new_p_end += 1
                    else:
                        if elements == len(precipitation) and new_p_end == 0:
                            preci_25_or_120days = elements
                            old_P_takeover = preci_vol
                            print(preci_25_or_120days)
                            remnant_list.append(preci_25_or_120days)
                            new_p_end += 1
                            reminanat_preci = enough_precip - preci_vol
                print(f'old_P_takeover = {old_P_takeover}')
                #                     cover += 1
                #                     border += 1
                reloop -= 1
                new_p_end = 0
                print('This is the old_year remnant')
                print(remnant_list)
                print('\n')

        elif water_cutoff1 == 'n' and day_cutoff1 == 'y':
            day_remnant = int(input('how many days are left from the previous year: '))
            store_input.append(day_remnant)
            print('\n')

            #         This takes out the remnant from the following year

            print('P applicaition dates')
            print(remnant_list)
            print('\n')
            preci_start = remnant_list[0]
            preci_vol = 0
            day_count = 0
            new_p_end = 0
            #         print(f'New P takes over on the {high_new_p_days[0]} day')
            reloop = len(remnant_list)
            preci_25_or_120days = 0
            while reloop > 0:
                for elements in range(preci_start, day_remnant + 1):
                    if new_p_end == 0:
                        preci_vol += float(precipitation[elements])
                        day_count += 1
                    if elements == day_remnant and new_p_end == 0:
                        preci_25_or_120days = elements
                        remnant_list.append(preci_25_or_120days - 1)
                        old_P_takeover = preci_vol
                        print(preci_25_or_120days)
                        new_p_end += 1
                    else:
                        if elements == day_remnant + 1 and new_p_end == 0:
                            preci_25_or_120days = elements
                            old_P_takeover = preci_vol
                            print(preci_25_or_120days)
                            remnant_list.append(preci_25_or_120days - 1)
                            new_p_end += 1
                            next_year_remender = enough_days - (elements - preci_start)
                print(f'old_P_takeover = {old_P_takeover}')
                #                     cover += 1
                #                     border += 1
                reloop -= 1
                new_p_end = 0
                print('This is the old_year remnant')
                print(remnant_list)
                print('\n')

    def fet_application():
        year = input('What year are you checking for: ')
        store_input.append(year)
#         print(year)
        year = int(year)
#         print(year)
        year = str(year)
#         print(year)
        b = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
        cycle = 3
        run = True
        while run:
            a = year
            if len(a) > 7:
                print('i am so sorry, you just exceeded the limit')
                run = False
            else:
#                 for numbers in range(0, 99):
                for numbers in range(0, 9999999):
#                 for numbers in range(0, 9):
                    if str(numbers) == a:
                        a = int(a)
                        if a % 4 == 0:
                            if a % 100 == 0:
                                if a % 400 == 0:
                                    if len(load) != 366 or len(flow) != 366:                            
                                        print(f'{a} is not matching with the data set (leap and non-leap)')
                                        exit()
                                    else:
                                        run = False
                                else:
                                    if len(load) != 365 or len(flow) != 365:                            
                                        print(f'{a} is not matching with the data set (leap and non-leap)')
                                        exit()
                                    else:
                                        run = False
                            else:
                                if len(load) != 366 or len(flow) != 366:                            
                                    print(f'{a} is not matching with the data set (leap and non-leap)')
                                    exit()
                                else:
                                    run = False
                        else:
                            if len(load) != 365 or len(flow) != 365:                            
                                print(f'{a} is not matching with the data set (leap and non-leap)')
                                exit()
                            else:
                                run = False
                    else:
                        if a == str(a):
                            for elements in a:
                                for letters in b:
                                    if numbers == a or elements == letters or elements == letters.lower():
                                        cycle -= 1
                                        if cycle == 0:
                                            print('i am so sorry we accept only decimal numbers')
                                            run = False
                                            
        print('\n')
# dba - days before application
        dba_list = []
        days_before_fet = 0
        initial_date = ''
#         print(len(initial_date))
        applications = int(input('How many fertilizer application above 3kg/ha was applied to the farm? '))
        store_input.append(applications)
        n = 1
        applications1 =  applications
        high_new_p_days = []
        if applications > 0:
            while applications > 0:
                date = input(f'''
    When was the {n} fertilizer applied?
    if it was applied on may 12th input 05/12: 
    ''')
                store_input.append(date)
    #             checking date order
                if len(initial_date) == 0:
                    initial_date = list(date)
    #                 print(initial_date)
                else:
                    current_date = list(date)
                    initial_month = int(initial_date[0] + initial_date[1])
                    initial_day = int(initial_date[3] + initial_date[4])
                    current_month = int(current_date[0] + current_date[1])
                    current_day = int(current_date[3] + current_date[4])
                    if initial_month > current_month:
                        print('The fertilizer application date has to be up in increasing date order')
    #                     print(initial_date)
                        exit()
                    elif initial_month == current_month:
                        if initial_day > current_day:
                            print('The fertilizer application date has to be up in increasing date order')
    #                         print(initial_date)
                            exit()
                        else:
                            initial_date = current_date
                    else:
                        initial_date = current_date
                month_list = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
                applications -= 1
                date_list = list(date)
    #             print(date_list)
                if len(load) == 366:
                    month_list[1] += 1
                month = int(date_list[0] + date_list[1])
                if month > 12:
                    print('There is a problem with the fertilizer application month')
                    exit()
                day = int(date_list[3] + date_list[4])
                
                if n == 1:
                    if month > 1:
                        fore_months = month - 2
                        while fore_months > - 1:
                            days_before_fet += month_list[fore_months]
                            fore_months -= 1
                        days_before_fet += day
                    else:
                        days_before_fet += day
                    print(f'There are {days_before_fet} days before fertilizer application')
                    dba_list.append(days_before_fet)
                    high_new_p_days.append(days_before_fet)
                    days_before_fet = 0
                else:
                    if month > 1:
                        fore_months = month - 2
                        while fore_months > - 1:
                            days_before_fet += month_list[fore_months]
                            fore_months -= 1
                        days_before_fet += day
                    else:
                        days_before_fet += day
                    dba_list.append(days_before_fet)
                    days_before_fet = 0
                n += 1
                if day > month_list[month - 1]:
                    print('There is a problem with the fertilizer application day')
                    exit()
                if len(precipitation) != len(load):
                    print('This is a problem with you precipitation')
                    exit()
            print('\n')
            print(dba_list)
            print('\n')
            water_cutoff = input('''Would you like to consider precipitation
    press Y for Yes
    Press N for No
    ''').lower()
            store_input.append(water_cutoff)
            print('\n')
            day_cutoff = input('''Would you like to consider end dates
    press Y for Yes
    press N for no
    ''').lower()
            store_input.append(day_cutoff)
            print('\n')
            if water_cutoff == 'y' and day_cutoff == 'y':
                high_risk_p = 0
                application_span = []
                ground = 0
                if applications1 > 1:
                    for elements in range(1, len(dba_list)):
                        span = dba_list[elements] - dba_list[ground]
                        application_span.append(span)
                        ground += 1
                        
                else:
    #            This is the regime of single applications  
                    print('P applicaition dates')
                    print(dba_list)
                    print('\n')
                    preci_start = dba_list[0]
                    preci_vol = 0
                    day_count = 0
                    new_p_end = 0
                    print(f'Old P takes over on the {high_new_p_days[0]} day')
                    reloop = len(dba_list)
                    preci_25_or_120days = 0
                    while reloop > 0:
                        for elements in range(preci_start, len(precipitation)):
                            if new_p_end == 0:
                                preci_vol += float(precipitation[elements])
                                day_count += 1
                            if preci_vol >= enough_precip and new_p_end == 0 or elements == preci_start + enough_days and new_p_end == 0:
                                preci_25_or_120days = elements
                                dba_list.append(preci_25_or_120days)
                                old_P_takeover = preci_vol
                                print(preci_25_or_120days)
                                new_p_end += 1
                            else:
                                if elements == len(precipitation) - 1 and new_p_end == 0:
                                    preci_25_or_120days = elements
                                    old_P_takeover = preci_vol
                                    print(preci_25_or_120days)
                                    dba_list.append(preci_25_or_120days)
                                    new_p_end += 1
                                    next_year_remender = enough_days -(elements - preci_start)
                                    reminanat_preci = enough_precip - preci_vol
                                    print(f'You have active new P still running and you have {next_year_remender}days usable in the next year or {reminanat_preci}cm of precipitation to attain')
                        print(f'old_P_takeover = {old_P_takeover}')
    #                     cover += 1
    #                     border += 1
                        reloop -= 1
                        new_p_end = 0
                        print('\n')
                        print('This is the old_year remnant')
                        print(remnant_list)
                        print('\n')
                        print('These are the new P application dates') 
                        print(dba_list)
                        bulk_active_p_date = []
                        if len(remnant_list) > 1:
                            bulk_active_p_date.append(remnant_list[0])
                            bulk_active_p_date.append(remnant_list[1])
                        for element in range(0, len(dba_list)):
                            bulk_active_p_date.append(dba_list[element])
                        print(f'''These are the whole active New-P days in the year
    {bulk_active_p_date}''')
                        return bulk_active_p_date
                      
                        
    #            This is the regime of multiple applications     
                if applications1 > 1:
                    print('P applicaition dates')
                    print(dba_list)
                    print('Span between P application dates')
                    print(application_span)
                    print('\n')
                    preci_start = dba_list[0]
                    preci_vol = 0
                    day_count = 0
                    new_p_end = 0
    #                 print(high_new_p_days)
                    reloop = len(dba_list)
                    preci_25_or_120days = 0
                    border = 1
                    cover = 1
                    old_P_takeover = 0
                    while reloop > 0:
                        if border < len(dba_list):
                            fet_reapp = dba_list[cover]
                        for elements in range(preci_start, len(precipitation)):
                #             print(elements)
                            if new_p_end == 0:
                                preci_vol += float(precipitation[elements])
                    #             print(precipitation[elements])
                                day_count += 1
                            if preci_vol >= enough_precip and new_p_end == 0 or elements == preci_start + enough_days and new_p_end == 0:
                                preci_25_or_120days = elements
                                old_P_takeover = preci_vol
    #                             print(preci_25_or_120days)
                                new_p_end += 1
                            else:
                                if elements == len(precipitation) - 1 and new_p_end == 0:
                                    preci_25_or_120days = elements
                                    old_P_takeover = preci_vol
    #                                 print(preci_25_or_120days)
                                    new_p_end += 1
                                    next_year_remender = enough_days -(elements - preci_start)
                                    reminanat_preci = enough_precip - preci_vol
                                    print(f'You have active new P still running and you have {next_year_remender}days usable in the next year or {reminanat_preci}cm of precipitation to attain')
                        print(f'old_P_takeover = {old_P_takeover}')
                        if preci_25_or_120days > fet_reapp or preci_vol >= enough_precip or preci_25_or_120days >= enough_days or preci_25_or_120days == len(precipitation):
                            cover += 1
                            border += 1
                            reloop -= 1
                            new_p_end = 0
                            if preci_25_or_120days > fet_reapp:
                                if cover <= len(dba_list):
                                    fet_reapp = dba_list[cover - 1]
                                    if fet_reapp > preci_25_or_120days:
                                        high_new_p_days.append(preci_25_or_120days)
                                        high_new_p_days.append(fet_reapp)
                                if cover <= len(dba_list):
                                    preci_start = fet_reapp
                                    high_new_p_days.append('-')
                                else:
                                    high_new_p_days.append(preci_25_or_120days)
                            elif preci_vol >= enough_precip or preci_25_or_120days >= enough_days :
                                high_new_p_days.append(preci_25_or_120days)
                                high_new_p_days.append(dba_list[cover - 1])
                                preci_start = dba_list[cover - 1]
            #                 print(high_new_p_days)
                            preci_vol = 0
                    print('\n')
                    print('This is the old_year remnant')
                    print(remnant_list)
                    print('\n')
                    print('These are the high P-paired days')
                    print(high_new_p_days)
                    bulk_active_p_date = []
                    if len(remnant_list) > 1:
                        bulk_active_p_date.append(remnant_list[0])
                        bulk_active_p_date.append(remnant_list[1])
                    for element in range(0, len(high_new_p_days)):
                        bulk_active_p_date.append(high_new_p_days[element])
                    print(f'''These are the whole active New-P days in the year
    {bulk_active_p_date}''')
                    return bulk_active_p_date
                                   
                    
            elif water_cutoff == 'y' and day_cutoff == 'n':
                high_risk_p = 0
                application_span = []
                ground = 0
                if applications1 > 1:
                    for elements in range(1, len(dba_list)):
                        span = dba_list[elements] - dba_list[ground]
                        application_span.append(span)
                        ground += 1
                        
                else:
    #            This is the regime of single applications  
                    print('P applicaition dates')
                    print(dba_list)
                    print('\n')
                    preci_start = dba_list[0]
                    preci_vol = 0
                    day_count = 0
                    new_p_end = 0
                    print(f'Old P takes over on the {high_new_p_days[0]} day')
                    reloop = len(dba_list)
                    preci_25_or_120days = 0
                    while reloop > 0:
                        for elements in range(preci_start, len(precipitation)):
                            if new_p_end == 0:
                                preci_vol += float(precipitation[elements])
                                day_count += 1
                            if preci_vol >= enough_precip and new_p_end == 0:
                                preci_25_or_120days = elements
                                dba_list.append(preci_25_or_120days)
                                old_P_takeover = preci_vol
                                print(preci_25_or_120days)
                                new_p_end += 1
                            else:
                                if elements == len(precipitation) - 1 and new_p_end == 0:
                                    preci_25_or_120days = elements
                                    old_P_takeover = preci_vol
                                    print(preci_25_or_120days)
                                    dba_list.append(preci_25_or_120days)
                                    new_p_end += 1
                                    next_year_remender = enough_days -(elements - preci_start)
                                    reminanat_preci = enough_precip - preci_vol
                                    print(f'You have active new P still running and you have {next_year_remender}days usable in the next year or {reminanat_preci}cm of precipitation to attain')
                        print(f'old_P_takeover = {old_P_takeover}')
    #                     cover += 1
    #                     border += 1
                        reloop -= 1
                        new_p_end = 0
                        print('\n')
                        print('This is the old_year remnant')
                        print(remnant_list)
                        print('\n')
                        print('These are the new P application dates')
                        print(dba_list)
                        bulk_active_p_date = []
                        if len(remnant_list) > 1:
                            bulk_active_p_date.append(remnant_list[0])
                            bulk_active_p_date.append(remnant_list[1])
                        for element in range(0, len(dba_list)):
                            bulk_active_p_date.append(dba_list[element])
                        print(f'''These are the whole active New-P days in the year
    {bulk_active_p_date}''')
                        return bulk_active_p_date
                      
                        
    #            This is the regime of multiple applications     
                if applications1 > 1:
                    print('P applicaition dates')
                    print(dba_list)
                    print('Span between P application dates')
                    print(application_span)
                    print('\n')
                    preci_start = dba_list[0]
                    preci_vol = 0
                    day_count = 0
                    new_p_end = 0
    #                 print(high_new_p_days)
                    reloop = len(dba_list)
                    preci_25_or_120days = 0
                    border = 1
                    cover = 1
                    old_P_takeover = 0
                    while reloop > 0:
                        if border < len(dba_list):
                            fet_reapp = dba_list[cover]
                        for elements in range(preci_start, len(precipitation)):
                #             print(elements)
                            if new_p_end == 0:
                                preci_vol += float(precipitation[elements])
                    #             print(precipitation[elements])
                                day_count += 1
                            if preci_vol >= enough_precip and new_p_end == 0:
                                preci_25_or_120days = elements
                                old_P_takeover = preci_vol
    #                             print(preci_25_or_120days)
                                new_p_end += 1
                            else:
                                if elements == len(precipitation) - 1 and new_p_end == 0:
                                    preci_25_or_120days = elements
                                    old_P_takeover = preci_vol
    #                                 print(preci_25_or_120days)
                                    new_p_end += 1
                                    reminanat_preci = enough_precip - preci_vol
                                    print(f'You have active new P still running and you have {next_year_remender}days usable in the next year or {reminanat_preci}cm of precipitation to attain')
                        print(f'old_P_takeover = {old_P_takeover}')
                        if preci_25_or_120days > fet_reapp or preci_vol >= enough_precip or preci_25_or_120days >= enough_days or preci_25_or_120days == len(precipitation):
                            cover += 1
                            border += 1
                            reloop -= 1
                            new_p_end = 0
                            if preci_25_or_120days > fet_reapp:
                                if cover <= len(dba_list):
                                    fet_reapp = dba_list[cover - 1]
                                    if fet_reapp > preci_25_or_120days:
                                        high_new_p_days.append(preci_25_or_120days)
                                        high_new_p_days.append(fet_reapp)
                                if cover <= len(dba_list):
                                    preci_start = fet_reapp
                                    high_new_p_days.append('-')
                                else:
                                    high_new_p_days.append(preci_25_or_120days)
                            elif preci_vol >= enough_precip:
                                high_new_p_days.append(preci_25_or_120days)
                                high_new_p_days.append(dba_list[cover - 1])
                                preci_start = dba_list[cover - 1]
            #                 print(high_new_p_days)
                            preci_vol = 0
                    print('\n')
                    print('This is the old_year remnant')
                    print(remnant_list)
                    print('\n')
                    print('These are the high P-paired days')
                    print(high_new_p_days)
                    bulk_active_p_date = []
                    if len(remnant_list) > 1:
                        bulk_active_p_date.append(remnant_list[0])
                        bulk_active_p_date.append(remnant_list[1])
                    for element in range(0, len(high_new_p_days)):
                        bulk_active_p_date.append(high_new_p_days[element])
                    print(f'''These are the whole active New-P days in the year
    {bulk_active_p_date}''')
                    return bulk_active_p_date
                    
            elif water_cutoff == 'n' and day_cutoff == 'y':
                high_risk_p = 0
                application_span = []
                ground = 0
                if applications1 > 1:
                    for elements in range(1, len(dba_list)):
                        span = dba_list[elements] - dba_list[ground]
                        application_span.append(span)
                        ground += 1
                        
                else:
    #            This is the regime of single applications  
                    print('P applicaition dates')
                    print(dba_list)
                    print('\n')
                    preci_start = dba_list[0]
                    preci_vol = 0
                    day_count = 0
                    new_p_end = 0
                    print(f'Old P takes over on the {high_new_p_days[0]} day')
                    reloop = len(dba_list)
                    preci_25_or_120days = 0
                    while reloop > 0:
                        for elements in range(preci_start, len(precipitation)):
                            if new_p_end == 0:
                                preci_vol += float(precipitation[elements])
                                day_count += 1
                            if elements == preci_start + enough_days and new_p_end == 0:
                                preci_25_or_120days = elements
                                dba_list.append(preci_25_or_120days)
                                old_P_takeover = preci_vol
                                print(preci_25_or_120days)
                                new_p_end += 1
                            else:
                                if elements == len(precipitation) - 1 and new_p_end == 0:
                                    preci_25_or_120days = elements
                                    old_P_takeover = preci_vol
                                    print(preci_25_or_120days)
                                    dba_list.append(preci_25_or_120days)
                                    new_p_end += 1
                                    next_year_remender = enough_days -(elements - preci_start)
                                    print(f'You have active new P still running and you have {next_year_remender}days usable in the next year or {reminanat_preci}cm of precipitation to attain')
                        print(f'old_P_takeover = {old_P_takeover}')
    #                     cover += 1
    #                     border += 1
                        reloop -= 1
                        new_p_end = 0
                        print('\n')
                        print('This is the old_year remnant')
                        print(remnant_list)
                        print('\n')
                        print('These are the new P application dates')
                        print(dba_list)
                        bulk_active_p_date = []
                        if len(remnant_list) > 1:
                            bulk_active_p_date.append(remnant_list[0])
                            bulk_active_p_date.append(remnant_list[1])
                        for element in range(0, len(dba_list)):
                            bulk_active_p_date.append(dba_list[element])
                        print(f'''These are the whole active New-P days in the year
    {bulk_active_p_date}''')
                        return bulk_active_p_date
                      
                        
    #            This is the regime of multiple applications     
                if applications1 > 1:
                    print('P applicaition dates')
                    print(dba_list)
                    print('Span between P application dates')
                    print(application_span)
                    print('\n')
                    preci_start = dba_list[0]
                    preci_vol = 0
                    day_count = 0
                    new_p_end = 0
    #                 print(high_new_p_days)
                    reloop = len(dba_list)
                    preci_25_or_120days = 0
                    border = 1
                    cover = 1
                    old_P_takeover = 0
                    while reloop > 0:
                        if border < len(dba_list):
                            fet_reapp = dba_list[cover]
                        for elements in range(preci_start, len(precipitation)):
                #             print(elements)
                            if new_p_end == 0:
                                preci_vol += float(precipitation[elements])
                    #             print(precipitation[elements])
                                day_count += 1
                            if elements == preci_start + enough_days and new_p_end == 0:
                                preci_25_or_120days = elements
                                old_P_takeover = preci_vol
    #                             print(preci_25_or_120days)
                                new_p_end += 1
                            else:
                                if elements == len(precipitation) - 1 and new_p_end == 0:
                                    preci_25_or_120days = elements
                                    old_P_takeover = preci_vol
    #                                 print(preci_25_or_120days)
                                    new_p_end += 1
                                    next_year_remender = enough_days -(elements - preci_start)
                                    reminanat_preci = enough_precip - preci_vol
                                    print(f'You have active new P still running and you have {next_year_remender}days usable in the next year or {reminanat_preci}cm of precipitation to attain')
                        print(f'old_P_takeover = {old_P_takeover}')
                        if preci_25_or_120days > fet_reapp or preci_vol >= enough_precip or preci_25_or_120days >= enough_days or preci_25_or_120days == len(precipitation):
                            cover += 1
                            border += 1
                            reloop -= 1
                            new_p_end = 0
                            if preci_25_or_120days > fet_reapp:
                                if cover <= len(dba_list):
                                    fet_reapp = dba_list[cover - 1]
                                    if fet_reapp > preci_25_or_120days:
                                        high_new_p_days.append(preci_25_or_120days)
                                        high_new_p_days.append(fet_reapp)
                                if cover <= len(dba_list):
                                    preci_start = fet_reapp
                                    high_new_p_days.append('-')
                                else:
                                    high_new_p_days.append(preci_25_or_120days)
                            elif preci_vol >= enough_precip:
                                high_new_p_days.append(preci_25_or_120days)
                                high_new_p_days.append(dba_list[cover - 1])
                                preci_start = dba_list[cover - 1]
            #                 print(high_new_p_days)
                            preci_vol = 0
                    print('\n')
                    print('This is the old_year remnant')
                    print(remnant_list)
                    print('\n')
                    print('These are the high P-paired days')
                    print(high_new_p_days)
                    bulk_active_p_date = []
                    if len(remnant_list) > 1:
                        bulk_active_p_date.append(remnant_list[0])
                        bulk_active_p_date.append(remnant_list[1])
                    for element in range(0, len(high_new_p_days)):
                        bulk_active_p_date.append(high_new_p_days[element])
                    print(f'''These are the whole active New-P days in the year
    {bulk_active_p_date}''')

                    return bulk_active_p_date
        else:
            return remnant_list
    def fit_data():
        ############################# This is where I peel the data into the various regimes#####################
        def linear_formula(vars, a, b, c, d):
            x, y = vars
            #         print(load)
            #         print(flow)
            #         print('\n')
            #         print('This is the chunck to take out')
            #         print(new_regime)
            y_rad = np.radians(y)  # Convert y to radians
#             print('This is the special y')
            print(y)
            pi = 3.1415926535897932384626433832795028841971693993751058209749445923
            return (a * x) + (b * np.sin(2 * pi * y_rad)) + (c * np.cos(2 * pi * y_rad)) + d

        #     We have to take out zeros given the that the natrual log will give an error for that case

        flow_takenout = []
        time_takenout = []
        load_takenout = []
        a = new_regime
        start = 0
        data = len(load)
        #         print(data)
        data_set = 0
        while data_set < 3:
            data_set += 1
            start = 0
            for element in range(0, data):
                if len(a) > 2:
                    Run = True
                    while Run:
                        if element < a[start]:
                            if data_set == 1:
                                flow_takenout.append(float(flow[element]))
                            elif data_set == 2:
                                load_takenout.append(float(load[element]))
                            elif data_set == 3:
                                weighted_time = element / (data - 1)
                                time_takenout.append(float(weighted_time))
                            #                             print(element)
                            Run = False
                        elif element < a[start + 1]:
                            Run = False
                            status = 'non_print'
                        else:
                            Run = False
                            if start + 1 <= len(a) - 3:
                                if data_set == 1:
                                    flow_takenout.append(float(flow[element]))
                                elif data_set == 2:
                                    load_takenout.append(float(load[element]))
                                elif data_set == 3:
                                    weighted_time = element / (data - 1)
                                    time_takenout.append(float(weighted_time))
                                #                                 print(element)
                                start += 2
                            else:
                                if data_set == 1:
                                    flow_takenout.append(float(flow[element]))
                                elif data_set == 2:
                                    load_takenout.append(float(load[element]))
                                elif data_set == 3:
                                    weighted_time = element / (data - 1)
                                    time_takenout.append(float(weighted_time))
                #                                 print(element)
                else:
                    if element < a[0]:
                        if data_set == 1:
                            flow_takenout.append(float(flow[element]))
                        elif data_set == 2:
                            load_takenout.append(float(load[element]))
                        elif data_set == 3:
                            weighted_time = element / (data - 1)
                            time_takenout.append(float(weighted_time))
                    #                         print(element)
                    elif element >= a[0] and element >= a[1]:
                        if data_set == 1:
                            flow_takenout.append(float(flow[element]))
                        elif data_set == 2:
                            load_takenout.append(float(load[element]))
                        elif data_set == 3:
                            weighted_time = element / (data - 1)
                            time_takenout.append(float(weighted_time))
        #                         print(element)

        print('\n')
        print(f'''This is your flow after new regime is taken out

{flow_takenout}''')
        print('\n')
        print(len(flow_takenout))
        print('\n')
        print('\n')
        print(f'''This is your load after new regime is taken out

{load_takenout}''')
        print('\n')
        print(len(load_takenout))
        print('\n')
        print('\n')
        print(f'''This is the time fractions after new regime is taken out

{time_takenout}''')
        print('\n')
        print(len(time_takenout))
        print('\n')

        def realog(x):
            if x == 0:
                new_status = 'zero taken out'
                return 0
            else:
                answer = math.log(x)
                return answer

        #                 print(answer)

        time_final = []
        load_final = []
        flow_final = []

        fitter = input('''How do you want to fit the data
                a. To use a 3D float fit Press 1
                b. To use a Machine learning fit Press 2
                ''')
        store_input.append(fitter)
        #         This part take out zeros (0), infs or NaNs
        for elements in range(0, len(flow_takenout)):
            if flow_takenout[elements] == 0 or flow_takenout[elements] == 'inf' or flow_takenout[elements] == 'NaN' or \
                    flow_takenout[elements] == 'None' or load_takenout[elements] == 0 or flow_takenout[
                elements] == 'invalid input' or load_takenout[elements] == 'invalid input':
                #             if flow_takenout[elements] == 0 or flow_takenout[elements] == 'inf' or flow_takenout[elements] == 'NaN':
                status_final = 'no use'
            else:
                # if fitter == '1':
                if fitter == '1' or fitter == '2':
                    time_final.append(time_takenout[elements])
                    answer = realog(load_takenout[elements])
                    load_final.append(answer)
                    # print(realog(load_takenout[elements]))
                    answer = realog(flow_takenout[elements])
                    flow_final.append(answer)
                #  print(realog(flow_takenout[elements]))

        #				This is the part that doesn't have the log in it for the machine learning
        #             elif fitter == '2':
        #                 time_final.append(time_takenout[elements])
        #                 answer = load_takenout[elements]
        #                 load_final.append(answer)
        # #                 print(realog(load_takenout[elements]))
        #                 answer = flow_takenout[elements]
        #                 flow_final.append(answer)
        # print(realog(flow_takenout[elements]))

        print('\n')
        print(f'''This is your flow after new regime is taken out

{flow_final}''')
        print('\n')
        print(len(flow_final))
        print('\n')
        print('\n')
        print(f'''This is your load after new regime is taken out

{load_final}''')
        print('\n')
        print(len(load_final))
        print('\n')
        print('\n')
        print(f'''This is the time fractions after new regime is taken out

{time_final}''')
        print('\n')
        print(len(time_final))
        print('\n')

        # Existing dataset with two independent variables

        flow_final_1 = []
        load_final_1 = []
        time_final_1 = []
        #
        for elements in range(0, len(flow_final)):
            if flow_final[elements] == 0 or flow_final[elements] == 'inf' or flow_final[elements] == 'NaN' or \
                    flow_final[elements] == 'None' or load_final[elements] == 0 or flow_final[
                elements] == 'invalid input' or load_final[elements] == 'invalid input':
                status_final_1 = 'no use'
            else:
                time_final_1.append(time_final[elements])
                load_final_1.append(load_final[elements])
                flow_final_1.append(flow_final[elements])
                # print(realog(flow_final[elements]))

        #         print('\n')
        #         print(f'''This is your flow after new regime is taken out
        #
        # {flow_final}''')
        #         print('\n')
        #         print(len(flow_final_1))
        #         print('\n')
        #         print('\n')
        #         print(f'''This is your load after new regime is taken out
        #
        # {load_final}''')
        #         print('\n')
        #         print(len(load_final_1))
        #         print('\n')
        #         print('\n')
        #         print(f'''This is the time fractions after new regime is taken out
        #
        # {time_final}''')
        #         print('\n')
        #         print(len(time_final_1))
        #         print('\n')

        if fitter == '1':
            x_data = np.array(flow_final_1, dtype=np.float64)
            y_data = np.array(time_final_1, dtype=np.float64)
            z_data = np.array(load_final_1, dtype=np.float64)

            # Check if arrays contain any NaNs or Infs and create a mask to filter them out
            mask = ~np.isnan(x_data) & ~np.isnan(y_data) & ~np.isnan(z_data) & ~np.isinf(x_data) & ~np.isinf(
                y_data) & ~np.isinf(z_data)

            # Apply the mask to filter out invalid data points
            x_data = x_data[mask]
            y_data = y_data[mask]
            z_data = z_data[mask]

            # Ensure there are enough data points after cleaning
            if len(x_data) < 4 or len(y_data) < 4 or len(z_data) < 4:
                raise ValueError("Not enough valid data points after cleaning to perform curve fitting")

            # Use curve fitting to estimate the coefficients
            popt, _ = curve_fit(linear_formula, (x_data, y_data), z_data)

            # Extract the estimated coefficients
            a, b, c, d = popt

            # Print the estimated coefficients
            print(f"Estimated coefficients: a = {a}, b = {b}, c = {c}, d = {d}")

            # Generate a new dataset using the fitted coefficients
            x_new = np.linspace(min(x_data), max(x_data), 20)
            y_new = np.linspace(min(y_data), max(y_data), 20)
            x_new, y_new = np.meshgrid(x_new, y_new)
            z_new = linear_formula((x_new, y_new), a, b, c, d)

            # Plot the original data and the fitted surface
            fig = plt.figure()
            ax = fig.add_subplot(111, projection='3d')
            ax.scatter(x_data, y_data, z_data, color='red', label='Original Data')
            ax.plot_surface(x_new, y_new, z_new, alpha=0.5, rstride=100, cstride=100)
            ax.set_xlabel('x')
            ax.set_ylabel('y')
            ax.set_zlabel('z')
            plt.legend()
            plt.show()
            print('You can take the equation, and try to forge a new data set')


        elif fitter == '2':
            a = open('Training_Simulated_data.txt', 'r')
            bx = []
            # split takes all the individual element and makes them elements of a list while
            # strip would divide it by lines and would only start a new list elements when there is a new line / or enter
            for lines in a:
                # c = we strip the lines with c, making every line an item
                c = lines.strip()
                # d = lines.split()
                bx.append(c)
            a.close()
            bx.remove(bx[0])
            # print(b)

            # load_final_1 = [0.355, 0.152, 0.154, 0.162, 0.169, 0.148, 0.162, 0.133, 0.117, 0.089, 0.174, 0.255, 0.121, 0.226, 0.067, 0.07, 0.069, 0.055, 0.049, 0.08, 0.061, 0.036, 0.037, 0.056, 0.039, 0.04, 0.032, 0.043, 0.051, 0.035, 0.077, 0.374, 0.188, 0.11, 0.083, 0.074, 0.053, 0.053, 0.052, 0.077, 0.082, 0.043, 0.051, 0.047, 0.228, 0.373, 0.181, 0.133, 0.08, 0.527, 0.584, 0.214, 0.1, 0.087, 0.135, 0.118, 0.172, 0.135, 0.05, 0.073, 0.046, 0.052, 0.042, 0.035, 0.033, 0.056, 0.076, 0.046, 0.083, 0.067, 0.084, 0.232, 0.062, 0.045, 0.044, 0.06, 0.04, 0.059, 0.031, 0.055, 0.058, 0.132, 0.751, 0.093, 0.045, 0.034, 0.36, 0.095, 0.057, 0.043, 0.044, 0.04, 0.036, 0.037, 0.034, 0.047, 0.04, 0.038, 0.033, 0.038, 0.036, 0.035, 0.034, 0.035, 0.038, 0.046, 0.044, 0.059, 0.107, 0.184, 0.05, 0.047, 0.054, 0.059, 0.034, 0.062, 0.039, 0.05, 0.051, 0.143, 0.091, 0.072, 0.058, 0.054, 0.149, 0.131, 0.123, 0.151, 0.128, 0.13, 0.137, 0.206, 0.211, 0.224, 0.103, 0.102, 0.112, 0.057, 0.068, 0.071, 0.088, 0.073, 0.074, 0.146, 0.072, 0.083, 0.199, 0.202, 0.199, 0.201, 0.203, 0.199, 0.179, 0.16, 0.14, 0.121, 0.038, 0.029, 0.047, 0.054, 0.061, 0.051, 0.026, 0.045 ,0.069, 0.066, 0.062, 0.059, 0.056, 0.055, 0.054, 0.052, 0.06, 0.067, 0.625, 0.61, 0.162, 0.103, 0.089, 0.074, 0.06, 0.09, 0.076, 0.059, 0.061, 0.062, 0.063, 0.11, 0.133, 0.093, 0.102, 0.087, 0.084, 0.082, 0.079, 0.077, 0.074, 0.071, 0.067, 0.064, 0.062, 0.061, 0.059, 0.057, 0.07, 0.093, 0.055, 0.051, 0.047, 0.047, 0.048, 0.048, 0.049, 0.049, 0.047, 0.047, 0.047, 0.05, 0.04, 0.049, 0.047, 0.051, 0.126, 0.126, 0.126, 0.099, 0.064, 0.068, 0.061, 0.062, 0.064, 0.066, 0.059, 0.068, 0.092, 0.063, 0.073, 0.061, 0.066, 0.054, 0.06, 0.077, 0.107, 0.049, 0.054, 0.053, 0.098, 0.05, 0.136, 0.124, 0.287, 0.275, 0.134, 0.13, 0.127, 0.125, 0.127, 0.127, 0.135, 0.13, 0.058, 0.257, 0.065, 0.056, 0.061, 0.062, 0.058, 0.058, 0.065, 0.07, 0.041, 0.043, 0.03, 0.032, 0.03, 0.028, 0.029, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.03, 0.009, 0.01, 0.027, 0.025, 0.023, 0.022, 0.021, 0.021, 0.021, 0.153, 0.069, 0.148, 0.058, 0.035, 0.064, 0.053, 0.036, 0.048, 0.037, 0.029, 0.032, 0.032, 0.004, 0.039, 0.045, 0.065, 0.045, 0.076, 0.04, 0.037, 0.106, 0.087, 0.086, 0.07, 0.068, 0.203, 0.164, 0.125, 0.085, 0.046, 0.046, 0.047, 0.048, 0.06, 0.084, 0.05, 0.051, 0.052, 0.053, 0.054, 0.055, 0.056, 0.057, 0.064, 0.071, 0.078, 0.085, 0.092, 0.099, 0.106, 0.113, 0.08, 0.068, 0.056, 0.055, 0.055, 0.071, 0.133, 0.11, 0.087, 0.064, 0.08, 0.096, 0.112, 0.16, 0.206, 0.184, 0.091, 0.071, 0.066, 0.062, 0.057, 0.056, 0.054, 0.052, 0.059, 0.187, 0.186, 0.235, 0.21, 0.185, 0.191, 0.197, 0.204, 0.198, 0.192, 0.187, 0.175, 0.202, 0.216, 0.213, 0.211, 0.208, 0.205, 0.202, 0.168, 0.19031, 0.13247, 0.11762, 0.085, 0.113, 0.142, 0.082, 0.075, 0.073, 0.072, 0.071, 0.066, 0.061, 0.069, 0.069, 0.076, 0.084, 0.091, 0.098, 0.105, 0.112, 0.119, 0.126, 0.133, 0.126, 0.119, 0.111, 0.104, 0.111, 0.245, 0.102, 0.111, 0.2, 0.327, 0.177, 0.062, 0.058, 0.057, 0.055, 0.064, 0.073, 0.074, 0.074, 0.075, 0.076, 0.076, 0.074, 0.071, 0.068, 0.065, 0.062, 0.059, 0.057, 0.054, 0.004, 0.008, 0.035, 0.062, 0.091, 0.119, 0.148, 0.058, 0.051, 0.06, 0.058, 0.056, 0.054, 0.053, 0.051, 0.049, 0.05, 0.052, 0.053, 0.053, 0.054, 0.056, 0.057, 0.055, 0.052, 0.05, 0.048, 0.048, 0.049, 0.05, 0.05, 0.051, 0.046, 0.047, 0.048, 0.05, 0.052, 0.054, 0.128, 0.318, 0.091]
            # print(len(load_final_1))
            # print('\n')
            # flow_final_1 = [0.033864719, 0.036077713, 0.012012411, 0.00573766, 0.003271581, 0.003176469, 0.002751211, 0.0014542, 0.0077384, 0.010256621, 0.515216161, 0.442206165, 0.136936422, 0.091453236, 0.055196286, 0.040672423, 0.069739385, 0.068038641, 0.091396179, 0.069895901, 0.108447711, 0.159881341, 0.121829051, 0.09325476, 0.071150397, 0.037996151, 0.040669943, 0.033302273, 0.01960535, 0.133478622, 0.233561517, 1.235779119, 0.490172611, 0.22417547, 0.172473509, 0.136268018, 0.10160674, 0.08479144, 0.055057002, 0.037054625, 0.033753684, 0.038464345, 0.029377112, 0.026779319, 0.571827026, 1.52522148, 0.417767644, 0.267220503, 0.212777706, 0.949878779, 1.6944, 0.907414064, 0.289515215, 0.283283306, 1.166869311, 1.175476045, 0.69417927, 0.534955916, 0.289768472, 0.221067081, 0.183196387, 0.313888034, 0.343096143, 0.281941251, 0.229691167, 0.180302999, 0.157566791, 0.138509118, 0.123485874, 0.094839633, 0.081237512, 0.061236205, 0.058706761, 0.059927612, 0.053435771, 0.19309137, 0.185186316, 0.15039184, 0.124538143, 0.109289477, 0.079373968, 0.367997696, 1.112708359, 0.369876309, 0.25990916, 0.204021132, 0.543381721, 0.440940026, 0.274429001, 0.216794546, 0.178100351, 0.149787588, 0.107792379, 0.074206553, 0.051808421, 0.040922746, 0.036584696, 0.037325059, 0.03175321, 0.011838184, 0.003284315, 0.004391962, 0.004491291, 0.004648143, 0.001587081, 7.28e-05, 0.000614, 0.039468068, 0.256673842, 0.816095572, 0.232990532, 0.137567105, 0.090457653, 0.060843848, 0.041636082, 0.031256352, 0.027568486, 0.015697421, 0.009962659, 0.993741557, 0.373858289, 0.112470122, 0.014359717, 0.002837583, 0.030968959, 0.016827352, 0.006428628, 0.004685607, 0.003668451, 0.002009562, 0.001464506, 0.002321243, 7.28e-05, 0.034562501, 0.072929564, 0.153768683, 0.146068788, 0.08295952, 0.067411755, 0.057823575, 0.045124598, 0.04067733, 0.037780671, 0.029671623, 0.024379097, 0.013715526, 0.012093387, 0.012246941, 0.012090689, 0.015003344, 0.012324007, 0.004021272, 0.003977823, 0.003882649, 0.004841493, 0.142753196, 0.099363856, 0.066656315, 0.05565996, 0.049999613, 0.13159236, 0.145518639, 0.079792803, 0.053820109,0.131535421, 0.095992719, 0.075509401, 0.061216245, 0.04981983, 0.040672421, 0.039401446, 0.027074024, 0.028084977, 0.025982222, 1.025219533, 1.56676043, 0.46128328, 0.238574268, 0.153655115, 0.107715474, 0.090947443, 0.191471451, 0.200298135, 0.111366749, 0.08253616, 0.06902673, 0.056500468, 0.311809341, 0.518362458, 0.376876233, 0.367630633, 0.307748253, 0.198831259, 0.144248444, 0.125754868, 0.137148656, 0.117761604, 0.09879106, 0.077952325, 0.068287346, 0.066768976, 0.049442689, 0.034308932, 0.034467237, 0.05617371, 0.184292463, 0.181851477, 0.109618002, 0.072407693, 0.068732721, 0.055566612, 0.045459138, 0.059649317, 0.059415374, 0.048999532, 0.043092596, 0.040839722, 0.037151772, 0.033074731, 0.033286218, 0.038774301, 0.051458827, 0.048438124, 0.035697229, 0.054717363, 0.24807295, 0.13015258, 0.094624441, 0.071008352, 0.052159393, 0.051656538, 0.047833152, 0.046705542, 0.044309588, 0.046506039, 0.036488812, 0.024043002, 0.02435378, 0.033154385, 0.030961446, 0.027319142, 0.153404665, 0.411693182, 0.178795944, 0.126184483, 0.104555615, 0.091472612, 0.081660615, 0.073635818, 0.068510042, 0.787973107, 0.697033506, 0.249798855, 0.1644175, 0.12465517, 0.10289329, 0.089225515, 0.079737325, 0.067058705, 0.063810381, 0.070994886, 0.573834792, 0.242935838, 0.148782999, 0.108458176, 0.093777453, 0.080424703, 0.054103184, 0.05429567, 0.039736082, 0.04678489, 0.074533937, 0.07677363, 0.061964085, 0.05207215, 0.039261697, 0.043099884, 0.03591786, 0.028974859, 0.030140931, 0.021170322, 0.026663259, 0.032506713, 0.025583806, 0.01626298, 0.018546391, 0.015850735, 0.010876381, 0.012891744, 0.011032044, 0.011469789, 0.010008474, 0.00665462, 0.710157554, 0.291397966, 0.219534806, 0.172246558, 0.131480984, 0.090969407, 0.091692493, 0.072512281, 0.052058046, 0.039973934, 0.0277957, 0.019179382, 0.017794346, 0.015544088, 0.015439692, 0.011782376, 0.013254742, 0.009159532, 0.010429144, 0.005542369, 0.00080572, 0.005822797, 0.116953734, 0.205665456, 0.102073731, 0.071253542, 0.600548271, 0.296951747, 0.144466025, 0.125457307, 0.095119563, 0.136575532, 0.1045526, 0.294751036, 0.067406364, 0.058084928, 0.032240706, 0.022112174, 0.014757564, 0.010326566, 0.006665312, 0.004411025, 0.002218308, 0.001014813, 0.001506454, 0.011504518, 0.872100839, 0.28081936, 0.125953145, 0.152217349, 0.637412503, 0.430387103, 0.286327969, 0.20397998, 0.169437213, 0.147799038, 0.126824443, 0.119597449, 0.109758757, 0.076356688, 0.066577735, 0.053934951, 0.03784723, 0.034923701, 0.031514613, 0.02652985, 1.018480923, 0.887127531, 0.35736307, 0.256522144, 0.187261751, 0.14832295, 0.124044622, 0.094237877, 0.086855658, 0.074565231, 0.06031091, 0.000679, 0.003904852, 0.009155564, 0.007809455, 0.005508842, 0.003967742, 0.002523082, 0.002625022, 0.002259268, 0.002090842, 0.0007427, 7.28e-05, 0.003691706, 0.007471293, 0.007658503, 0.003817985, 0.002572733, 0.0009806, 0.0006723, 7.28e-05, 0.321543402, 0.12651244, 0.487196868, 0.184524793, 0.155028906, 1.166195441, 0.319108029, 0.157830518, 0.096904502, 0.06800448, 0.049470336, 0.039081171, 0.032832819, 0.031804465, 0.025989412, 0.026134059, 0.017119014, 0.018488274, 0.021216615, 0.012604551, 0.010172618, 0.011688245, 0.01091363, 0.01208886, 0.011608944, 0.006150984, 0.004373025, 0.003754667, 0.220317062, 0.915226212, 0.223291654, 0.124252262, 0.127559111, 1.167682777, 0.942735821, 0.238645751, 0.137703798, 0.100817234, 0.071201557, 0.057608764, 0.045051554, 0.036587049, 0.038051076, 0.029566644, 0.024942707, 0.018411391, 0.01986963, 0.021842673, 0.026035321, 0.0348261, 0.040742258, 0.08069715, 0.098413731, 0.06626962, 0.065159303, 0.046725914, 0.05031459, 0.041199279, 0.033680081, 0.026294997, 0.473456673, 0.194042548, 0.127628023, 0.102333948, 0.245381761, 0.248883223, 0.160661264, 0.112923871, 0.078270934, 0.063267354, 0.051836952, 0.053650745, 0.055424236, 0.043362439, 0.038072635, 0.039208, 0.04178681, 0.039382642, 0.023106425, 0.02166479, 0.025055595, 0.01813437, 0.01432266, 0.011401091, 0.015152399, 0.013985903, 0.015145911, 0.011993419, 0.013745388, 0.011109125, 0.009010361, 0.009864049, 0.321576533, 1.251031079, 0.261281532]
            # print(len(flow_final_1))
            # print('\n')
            # time_final_1 = [0.005494505494505495, 0.008241758241758242, 0.01098901098901099, 0.013736263736263736, 0.016483516483516484, 0.019230769230769232, 0.02197802197802198, 0.024725274725274724, 0.04395604395604396, 0.046703296703296704, 0.04945054945054945, 0.0521978021978022, 0.054945054945054944, 0.057692307692307696, 0.06043956043956044, 0.06318681318681318, 0.06593406593406594, 0.06868131868131869, 0.07142857142857142, 0.07417582417582418, 0.07692307692307693, 0.07967032967032966, 0.08241758241758242, 0.08516483516483517, 0.08791208791208792, 0.09065934065934066, 0.09340659340659341, 0.09615384615384616, 0.0989010989010989, 0.10164835164835165, 0.1043956043956044, 0.10714285714285714, 0.10989010989010989, 0.11263736263736264, 0.11538461538461539, 0.11813186813186813, 0.12087912087912088, 0.12362637362637363, 0.12637362637362637, 0.12912087912087913, 0.13186813186813187, 0.1346153846153846, 0.13736263736263737, 0.1401098901098901, 0.14285714285714285, 0.14560439560439561, 0.14835164835164835, 0.1510989010989011, 0.15384615384615385, 0.1565934065934066, 0.15934065934065933, 0.1620879120879121, 0.16483516483516483, 0.16758241758241757, 0.17032967032967034, 0.17307692307692307, 0.17582417582417584, 0.17857142857142858, 0.1813186813186813, 0.18406593406593408, 0.18681318681318682, 0.18956043956043955, 0.19230769230769232, 0.19505494505494506, 0.1978021978021978, 0.20054945054945056, 0.2032967032967033, 0.20604395604395603, 0.2087912087912088, 0.21153846153846154, 0.21428571428571427, 0.21703296703296704, 0.21978021978021978, 0.22252747252747251, 0.22527472527472528, 0.22802197802197802, 0.23076923076923078, 0.23351648351648352, 0.23626373626373626, 0.23901098901098902, 0.24175824175824176, 0.2445054945054945, 0.24725274725274726, 0.25, 0.25274725274725274, 0.2554945054945055, 0.25824175824175827, 0.260989010989011, 0.26373626373626374, 0.2664835164835165, 0.2692307692307692, 0.27197802197802196, 0.27472527472527475, 0.2774725274725275, 0.2802197802197802, 0.28296703296703296, 0.2857142857142857, 0.28846153846153844, 0.29120879120879123, 0.29395604395604397, 0.2967032967032967, 0.29945054945054944, 0.3021978021978022, 0.30494505494505497, 0.3076923076923077, 0.3131868131868132, 0.31868131868131866, 0.32142857142857145, 0.3241758241758242, 0.3269230769230769, 0.32967032967032966, 0.3324175824175824, 0.33516483516483514, 0.33791208791208793, 0.34065934065934067, 0.3434065934065934, 0.34615384615384615, 0.3489010989010989, 0.3516483516483517, 0.6456043956043956, 0.6483516483516484, 0.6510989010989011, 0.6538461538461539, 0.6565934065934066, 0.8296703296703297, 0.8324175824175825, 0.8351648351648352, 0.8379120879120879, 0.8406593406593407, 0.8434065934065934, 0.8489010989010989, 0.8901098901098901, 0.8928571428571429, 0.9175824175824175, 0.9203296703296703, 0.9230769230769231, 0.9258241758241759, 0.9285714285714286, 0.9313186813186813, 0.9340659340659341, 0.9368131868131868, 0.9395604395604396, 0.9423076923076923, 0.945054945054945, 0.9478021978021978, 0.9505494505494505, 0.9532967032967034, 0.9560439560439561, 0.9587912087912088, 0.9615384615384616, 0.9642857142857143, 0.967032967032967, 0.9697802197802198, 0.9725274725274725, 0.9752747252747253, 0.978021978021978, 0.9807692307692307, 0.9835164835164835, 0.9862637362637363, 0.989010989010989, 0.9917582417582418, 0.9945054945054945, 0.9972527472527473, 1.0 ,0.0, 0.0027397260273972603, 0.005479452054794521, 0.00821917808219178, 0.010958904109589041, 0.0136986301369863, 0.01643835616438356, 0.019178082191780823, 0.021917808219178082, 0.024657534246575342, 0.0273972602739726, 0.030136986301369864, 0.03287671232876712, 0.03561643835616438, 0.038356164383561646, 0.0410958904109589, 0.043835616438356165, 0.04657534246575343, 0.049315068493150684, 0.052054794520547946, 0.0547945205479452, 0.057534246575342465, 0.06027397260273973, 0.06301369863013699, 0.06575342465753424, 0.0684931506849315, 0.07123287671232877, 0.07397260273972603, 0.07671232876712329, 0.07945205479452055, 0.0821917808219178, 0.08493150684931507, 0.08767123287671233, 0.09041095890410959, 0.09315068493150686, 0.0958904109589041, 0.09863013698630137, 0.10136986301369863, 0.10410958904109589, 0.10684931506849316, 0.1095890410958904, 0.11232876712328767, 0.11506849315068493, 0.1178082191780822, 0.12054794520547946, 0.1232876712328767, 0.12602739726027398, 0.12876712328767123, 0.13150684931506848, 0.13424657534246576, 0.136986301369863, 0.13972602739726028, 0.14246575342465753, 0.14520547945205478, 0.14794520547945206, 0.1506849315068493, 0.15342465753424658, 0.15616438356164383, 0.1589041095890411, 0.16164383561643836, 0.1643835616438356, 0.16986301369863013, 0.1726027397260274, 0.17534246575342466, 0.1780821917808219, 0.18082191780821918, 0.18356164383561643, 0.1863013698630137, 0.18904109589041096, 0.1917808219178082, 0.19452054794520549, 0.19726027397260273, 0.2, 0.20273972602739726, 0.2054794520547945, 0.20821917808219179, 0.21095890410958903, 0.2136986301369863, 0.21643835616438356, 0.2191780821917808, 0.2219178082191781, 0.22465753424657534, 0.2273972602739726, 0.23013698630136986, 0.2328767123287671, 0.2356164383561644, 0.23835616438356164, 0.2410958904109589, 0.24383561643835616, 0.2465753424657534, 0.2493150684931507, 0.25205479452054796, 0.2547945205479452, 0.25753424657534246, 0.2602739726027397, 0.26301369863013696, 0.26575342465753427, 0.2684931506849315, 0.27123287671232876, 0.273972602739726, 0.27671232876712326, 0.27945205479452057, 0.2821917808219178, 0.28493150684931506, 0.2876712328767123, 0.29041095890410956, 0.29315068493150687, 0.2958904109589041, 0.29863013698630136, 0.3013698630136986, 0.3041095890410959, 0.30684931506849317, 0.3095890410958904, 0.31232876712328766, 0.3150684931506849, 0.3178082191780822, 0.32054794520547947, 0.3232876712328767, 0.32602739726027397, 0.3287671232876712, 0.3315068493150685, 0.33424657534246577, 0.336986301369863, 0.33972602739726027, 0.3424657534246575, 0.3452054794520548, 0.34794520547945207, 0.3506849315068493, 0.35342465753424657, 0.0, 0.0027472527472527475, 0.005494505494505495, 0.008241758241758242, 0.01098901098901099, 0.013736263736263736, 0.016483516483516484, 0.019230769230769232, 0.02197802197802198, 0.024725274725274724, 0.027472527472527472, 0.03021978021978022, 0.03296703296703297, 0.03571428571428571, 0.038461538461538464, 0.04120879120879121, 0.04395604395604396, 0.046703296703296704, 0.04945054945054945, 0.0521978021978022, 0.054945054945054944, 0.057692307692307696, 0.06043956043956044, 0.06318681318681318, 0.06593406593406594, 0.06868131868131869, 0.10164835164835165, 0.1043956043956044, 0.10714285714285714, 0.10989010989010989, 0.11263736263736264, 0.11538461538461539, 0.11813186813186813, 0.12087912087912088, 0.15384615384615385, 0.1565934065934066, 0.15934065934065933, 0.1620879120879121, 0.16483516483516483, 0.16758241758241757, 0.17032967032967034, 0.17307692307692307, 0.17582417582417584, 0.17857142857142858, 0.1813186813186813, 0.18406593406593408, 0.18681318681318682, 0.18956043956043955, 0.19230769230769232, 0.19505494505494506, 0.1978021978021978, 0.20054945054945056, 0.2032967032967033, 0.20604395604395603, 0.2087912087912088, 0.21153846153846154, 0.21428571428571427, 0.21703296703296704, 0.21978021978021978, 0.22252747252747251, 0.22527472527472528, 0.22802197802197802, 0.23076923076923078, 0.23351648351648352, 0.23626373626373626, 0.23901098901098902, 0.24175824175824176, 0.2445054945054945, 0.24725274725274726, 0.25, 0.25274725274725274, 0.2554945054945055, 0.25824175824175827, 0.260989010989011, 0.26373626373626374, 0.2664835164835165, 0.2692307692307692, 0.5796703296703297, 0.6510989010989011, 0.6538461538461539, 0.6565934065934066, 0.6593406593406593, 0.6620879120879121, 0.6648351648351648, 0.6675824175824175, 0.6703296703296703, 0.6730769230769231, 0.6758241758241759, 0.6813186813186813, 0.6978021978021978, 0.7005494505494505, 0.7032967032967034, 0.7060439560439561, 0.7087912087912088, 0.7115384615384616, 0.7142857142857143, 0.717032967032967, 0.7417582417582418, 0.7445054945054945, 0.7472527472527473, 0.75, 0.7527472527472527, 0.7554945054945055, 0.7582417582417582, 0.760989010989011, 0.7637362637362637, 0.7664835164835165, 0.7692307692307693, 0.771978021978022, 0.7747252747252747, 0.7774725274725275, 0.7802197802197802, 0.782967032967033, 0.7857142857142857, 0.7884615384615384, 0.7912087912087912, 0.7939560439560439, 0.7967032967032966, 0.7994505494505495, 0.8021978021978022, 0.804945054945055, 0.8076923076923077, 0.8104395604395604, 0.8131868131868132, 0.8159340659340659, 0.8186813186813187, 0.8214285714285714, 0.8241758241758241, 0.8269230769230769, 0.8296703296703297, 0.8324175824175825, 0.8351648351648352, 0.8379120879120879, 0.8406593406593407, 0.8434065934065934, 0.8461538461538461, 0.8489010989010989, 0.8516483516483516, 0.8543956043956044, 0.8571428571428571, 0.8598901098901099, 0.8626373626373627, 0.8653846153846154, 0.8681318681318682, 0.8708791208791209, 0.8736263736263736, 0.8763736263736264, 0.8791208791208791, 0.8818681318681318, 0.8846153846153846, 0.8873626373626373, 0.8901098901098901, 0.8928571428571429, 0.8956043956043956, 0.8983516483516484, 0.9010989010989011, 0.9038461538461539, 0.9065934065934066, 0.9093406593406593, 0.9120879120879121, 0.9148351648351648, 0.9175824175824175, 0.9203296703296703, 0.9230769230769231, 0.9258241758241759, 0.9285714285714286, 0.9313186813186813, 0.9340659340659341, 0.9368131868131868, 0.9395604395604396, 0.9423076923076923, 0.945054945054945, 0.9478021978021978, 0.9505494505494505, 0.9532967032967034, 0.9560439560439561, 0.9587912087912088, 0.9615384615384616, 0.9642857142857143, 0.967032967032967, 0.9697802197802198, 0.9725274725274725, 0.9752747252747253, 0.978021978021978, 0.9807692307692307, 0.9835164835164835, 0.9862637362637363, 0.989010989010989, 0.9917582417582418, 0.9945054945054945, 0.9972527472527473, 1.0]
            # print(len(time_final_1))
            # print('\n')
            # [97, 145]

            loop = 0
            while loop <= 3:
                b = []
                new_a = ''
                loop += 1
                if loop == 1:
                    # a = input('Input the load list: ')
                    a = bx[0]
                elif loop == 2:
                    # a = input('Input the Drainage Discharge list: ')
                    a = bx[1]
                elif loop == 3:
                    # a = input('Input the Time Fractions: ')
                    a = bx[2]
                else:
                    # a = input('Input the window of the new P regime: ')
                    a = bx[3]
                for elements in range(0, len(a)):
                    if elements + 1 <= len(a) - 1:
                        c = ''
                        shift = 1
                        locked = True
                        first_pick = True
                        while locked:
                            if elements <= 1:
                                if a[elements] != '[' and a[elements] != ']' and a[elements] != ',':
                                    if first_pick:
                                        c += a[elements]
                                        first_pick = False
                                    if elements + shift <= len(a) - 1:
                                        if a[elements + shift] != ',' and a[elements + shift] != ']':
                                            c += a[elements + shift]
                                            shift += 1
                                        else:
                                            b.append(c)
                                            locked = False
                                    else:
                                        b.append(c)
                                        locked = False
                                else:
                                    locked = False
                            elif a[elements - 1] == ',':
                                if a[elements] != '[' and a[elements] != ']' and a[elements] != ',':
                                    if first_pick:
                                        c += a[elements]
                                        first_pick = False
                                    if elements + shift <= len(a) - 1:
                                        if a[elements + shift] != ',' and a[elements + shift] != ']':
                                            c += a[elements + shift]
                                            shift += 1
                                        else:
                                            b.append(c)
                                            locked = False
                                    else:
                                        b.append(c)
                                        locked = False
                                else:
                                    locked = False
                            else:
                                locked = False
                
#                 print('Emeke this is the fixing juncture')
#                 print(b)
#                 print('\n')
                for elements in range(0, len(b)):
                    repost = ''
                    for element in b[elements]:
                        if element != '"' and element != '\'':
                            repost += element
                    b[elements] = repost

                if loop == 1:
                    load_final_1 = []
                    for elements in range(0, len(b)):
                        y = float(b[elements])
                        load_final_1.append(y)

                elif loop == 2:
                    flow_final_1 = []
                    for elements in range(0, len(b)):
                        y = float(b[elements])
                        flow_final_1.append(y)

                elif loop == 3:
                    time_final_1 = []
                    for elements in range(0, len(b)):
                        y = float(b[elements])
                        time_final_1.append(y)

                else:
                    new_P_window = []
                    for elements in range(0, len(b)):
                        y = float(b[elements])
                        new_P_window.append(y)
                        
            
#             print('Final_Flow_full_data')
#             print(flow_final_1)
#             print(len(flow_final_1))
#             print('\n')
#             print(load_final_1)
#             print(len(load_final_1))
#             print('\n')
#             print('Emmy this is your final time')
#             print(time_final_1)
#             print(len(time_final_1))
#             print('\n')

            # outing zero
            zero_out_load = []
            zero_out_flow = []
            zero_out_time = []
#             print(len(load_final_1))
#             print(len(time_final_1))
#             print(len(flow_final_1))
#             print('\n')
            print('if the code breakes around here, just know that you training data set might be even, check for the length of the data set in the txt file')
            print('\n')
            for elements in range(0, len(load_final_1)):
                if load_final_1[elements] != 0.0 and flow_final_1[elements] != 0.0:
                    zero_out_time.append(time_final_1[elements])
                    zero_out_load.append(load_final_1[elements])
                    zero_out_flow.append(flow_final_1[elements])
                else:
                    a = 'Emeka if cound zero at '
#                     print(f'{a} {elements}')
#                     if load_final_1[elements] == 0:
#                         print('Emeka look at the load file')
#                     else:
#                         print('Emeka look at the flow file')
            # print(zero_out_flow)
            # print(len(zero_out_flow))
            # print('\n')
            # print(zero_out_load)
            # print(len(zero_out_load))
            # print('\n')
            # print(zero_out_time)
            # print(len(zero_out_time))
            # print('\n')
            load_final_1 = zero_out_load
            flow_final_1 = zero_out_flow
            time_final_1 = zero_out_time
            #
            # print('These are the training data')

            # print('\n')
            # print('load_final')
            # print(load_final_1)
            # print(len(load_final_1))
            # print('\n')
            # print('flow_final_1')
            # print(flow_final_1)
            # print(len(flow_final_1))
#             print('\n')
#             print('Emmy, this is the final timee')
#             print('time_final_1')
#             print(time_final_1)
#             print(len(time_final_1))
#             print('\n')
            # print('New_p_window')
            # print(new_P_window)
            # print(len(new_P_window))
            # print('\n')

            def realog(x):
                if x == 0:
                    new_status = 'zero taken out'
                    return 0
                else:
                    answer = math.log(x)
                    # print(answer)
                    return answer

            log_training_flow = []
            log_training_load = []
            for elements in range(0, len(load_final_1)):
                log_training_load.append(realog(load_final_1[elements]))
                log_training_flow.append(realog(flow_final_1[elements]))

            # print('\n')
            # print('log_training_load')
            # print(log_training_load)
            # print(len(log_training_load))
            # print('\n')
            # print('log_training_flow')
            # print(log_training_flow)
            # print(len(log_training_flow))
            # print('\n')
            # print('time_final_1')
            # print(time_final_1)
            # print(len(time_final_1))
            # print('\n')
            # print('New_p_window')
            # print(new_P_window)
            # print(len(new_P_window))
            # print('\n')

            #
            a = open('year_load_fet.txt', 'r')
            bx = []
            # split takes all the individual element and makes them elements of a list while
            # strip would divide it by lines and would only start a new list elements when there is a new line / or enter
            for lines in a:
                # c = we strip the lines with c, making every line an item
                # c = lines.strip()
                d = lines.split()
                bx.append(d)
            a.close()
            # print(bx)
            # print(len(bx))
            #
            a1 = open('year_drainage_discharge_fet.txt', 'r')
            bx1 = []
            for lines in a1:
                # c = we strip the lines with c, making every line an item
                # c = lines.strip()
                d = lines.split()
                bx1.append(d)
            a1.close()
            # print(bx1)
            # print(len(bx1))

            # This is for the load that is to be simulated

            bxx = []
            for elements in bx:
                if len(elements) > 0:
                    bxx.append(float(elements[0]))
                else:
                    bxx.append(0)
            # print(bxx)
            # print(len(bxx))
            #

            # This is drainage discharge for the corresponding load that is simulated

            bxx1 = []
            for elements in bx1:
                if len(elements) > 0:
                    bxx1.append(float(elements[0]))
                else:
                    bxx1.append(0)
            # print(bxx1)
            # print(len(bxx1))
            #
            Active_new_p_load = []
            Active_new_p_discharge = []
            members = 0
            print('This is the new P window')
            print(new_P_window)
            print(len(new_P_window))
            print('\n')
            while members < len(new_P_window):
                for elements in range(int(new_P_window[members]), int(new_P_window[members + 1])):
                    if elements != '' and elements != 0:
                        Active_new_p_load.append(bxx[elements])
                        Active_new_p_discharge.append(bxx1[elements])
                        # print(bxx[elements])
                        # print(bxx1[elements])
                    else:
                        Active_new_p_load.append(bxx[elements])
                        Active_new_p_discharge.append(bxx1[elements])
                        # print(bxx[elements])
                        # print(bxx1[elements])
                members += 2
#             print('These are the New_ps')
#             print(Active_new_p_load)
#             print(f'Length of New P - {len(Active_new_p_load)}')
#             print('\n')
#             print('These are the New_p_discharge')
#             print(Active_new_p_discharge)
#             print(f'Length of New P - {len(Active_new_p_discharge)}')
#             print('\n')

            log_Active_new_p_load = []
            log_Active_new_p_discharge = []

            members = 0
            new_p_time = []
            # print(len(bx))
            # print('You want to see this Emeka')
            # print(new_P_window)
#             print((new_P_window[members]) + 1)
            while members < len(new_P_window)/2:
#                 print('You want to see this Emeka')
#                 print((new_P_window[members]) + 1)
#                 print((new_P_window[members + 1]) + 2)
                for elements in range(int(new_P_window[2 * members]) + 1, int(new_P_window[(2 * members) + 1]) + 1):
                    a = elements / len(bx)
                    new_p_time.append(a)
                members += 1
            print('Time Fractions')
            if calibration == 'y':
                new_p_time = specific_time
            print(new_p_time)
            print(f' {len(new_p_time)}')
            print('\n')
            
            # take out zeros
            zero_out_Active_new_p_load = []
            zero_out_Active_new_p_discharge = []
            zero_out_new_p_time = []
            trueflow = []
            for elements in range(0, len(Active_new_p_load)):
                if Active_new_p_load[elements] != 0 and Active_new_p_discharge[elements] != 0:
                    trueflow.append(Active_new_p_discharge[elements])
                    zero_out_new_p_time.append(new_p_time[elements])
                    zero_out_Active_new_p_discharge.append(Active_new_p_discharge[elements])
                    zero_out_Active_new_p_load.append(Active_new_p_load[elements])

#             print(zero_out_Active_new_p_discharge)
#             print(zero_out_Active_new_p_load)
#             print(zero_out_new_p_time)

            Active_new_p_load = zero_out_Active_new_p_load
            Active_new_p_discharge = zero_out_Active_new_p_discharge
            new_p_time = zero_out_new_p_time

#             print('Emeka look here')
#             print(Active_new_p_load)
#             print(len(Active_new_p_load))
#             print(Active_new_p_discharge)
#             print(len(Active_new_p_discharge))
#             print('This is the zero out event')
#             print(new_p_time)
#             print(len(new_p_time))
            #
            for elements in Active_new_p_load:
                if elements != 0:
                    log_Active_new_p_load.append(realog(elements))
                else:
                    log_Active_new_p_load.append(0)
            
            print('This is the cleaned up new P drainage discharge')
            print(Active_new_p_discharge)
            print(len(Active_new_p_discharge))
            print('\n')
            
            for elements in Active_new_p_discharge:
                if elements != 0:
                    log_Active_new_p_discharge.append(realog(elements))
                else:
                    log_Active_new_p_discharge.append(0)
#                     print('Hey Emeka I got a zero  here')
#                     print(f'it is at pint {elements}')
            print('Log new P')
            print(log_Active_new_p_load)
            print(len(log_Active_new_p_load))
            print('\n')
            print('Log Discharge')
            print(log_Active_new_p_discharge)
            print(len(log_Active_new_p_discharge))
            print('\n')
            if len(log_Active_new_p_load) == 0:
                print('You do not have any data points during this new P period')
                for elements in store_input:
                    print(elements)
                print('\n')
                exit()

            Y = np.array(log_training_load, dtype=float)
#             print(Y)
#             print(len(Y))
            Q = np.array(log_training_flow, dtype=float)
            t = np.array(time_final_1, dtype=float)
#             print('This is the special time')
#             print(t)

            # Prepare the features
            X = np.column_stack((Q, np.sin(2 * np.pi * t), np.cos(2 * np.pi * t)))

            # Create and fit the linear regression model
            model = LinearRegression()
            model.fit(X, Y)

            # Print coefficients
            print("Base Flow Model coefficients:")
            aaa = f"{model.coef_[0]}"
            bbb = f"{model.coef_[1]}"
            ccc = f"{model.coef_[2]}"
            ddd = f"{model.intercept_}"
            print(f"β1 = {model.coef_[0]}")
            print(f"β2 = {model.coef_[1]}")
            print(f"β3 = {model.coef_[2]}")
            print(f"β0 = {model.intercept_}")
            
            coefs_ = []
            for elements in range(0, 4):
                if elements < 4:
                    if elements == 0:
                        coefs_.append(aaa)
                    elif elements == 1:
                        coefs_.append(bbb)
                    elif elements == 2:
                        coefs_.append(ccc)
                    else:
                        coefs_.append(ddd)
            
#             print('\n')
#             print('These are the coefficients')
#             print(coefs_)
#             print('\n')
            # Calculate and print the mean squared error
            y_pred = model.predict(X)
            mse = mean_squared_error(Y, y_pred)
            print(f"Mean Squared Error: {mse}")
            print('\n')
            Y_pred_full = model.predict(X)
            # print('X - This contains elements in the function')
            # print(X)
#             print('This is the log of the original data used in the training')
#             print(log_training_load)
#             print(len(log_training_load))
#             print('\n')
#             print('Y Training Predictions')
            Y_list = Y_pred_full.tolist()
#             print(Y_list)
#             print(len(Y_list))
#             print('\n')

            Total_drift = 0
            for elements in range(0, len(log_training_load)):
                Total_drift += log_training_load[elements] - Y_list[elements]
                # print(total_dif)
            mean_drift = Total_drift / len(Y_list)

            print('mean drift in training data set')
            print(mean_drift)
            mean_drift = 0
            print('\n')

            Training_last_display = []
            for elements in Y_list:
                a = mean_drift + elements
                # a = elements
                Training_last_display.append(a)

            for elements in range(0, len(Training_last_display)):
                Y_list[elements] = float(Training_last_display[elements])

            # print("Training Y values bumped with mean difference")
            # print(Training_last_display)
            # print(len(Training_last_display))
            # print('\n')

            def e(x):
                e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353
                xx = e**x
                return(xx)

            Real_predicted_Y = []
            for elements in range(0, len(Y_list)):
                real = e(Y_list[elements])
                Real_predicted_Y.append(real)

#             print('This is the real of the first predicted Y before prop up')
#             print(Real_predicted_Y)
#             print(len(Real_predicted_Y))
#             print('\n')

            # Function to make predictions for new Q and t values
            show_y = []

            def predict_y(Q_new, t_new):
                Q_new = np.array(Q_new, dtype=float)
                t_new = np.array(t_new, dtype=float)
                X_new = np.column_stack((Q_new, np.sin(2 * np.pi * t_new), np.cos(2 * np.pi * t_new)))
                y_new_pred = model.predict(X_new)
                show_y.append(y_new_pred)
#                 print('This is the show Y')
#                 print(show_y)
                return y_new_pred

            # Example usage for new Q and t values
            # Q_new = ['-1.5', '-2.0']
            # t_new = ['0.1', '0.2']

            Q_new = log_Active_new_p_discharge
            t_new = new_p_time
            y_new_pred = predict_y(Q_new, t_new)
#             print("Predicted Y values for new Q and t:")
            simulated = list(show_y[0])
#             print(y_new_pred)
#             print(show_y)
#             print(len(show_y[0]))

            total_dif = 0
#             print('This is the length of log active new p load')
#             print(log_Active_new_p_load)
#             print(len(log_Active_new_p_load))
#             print('\n')
            for elements in range(0, len(log_Active_new_p_load)):
                total_dif += (log_Active_new_p_load[elements] - simulated[elements])
#                 print(log_Active_new_p_load[elements])
#                 print(simulated[elements])
#                 print(total_dif)
#                 print(total_dif)
            mean_dif = total_dif / len(simulated)
            print('This is the mean magnitude difference for the old p in the new P regime')
            print(mean_dif)
            mean_dif = 0
            print('\n')


            # I had to redefine the mean difference here so I nulify the effect of multiplying the fitting function
            # mean_dif = 1

            # print('on call Emeka')
            # print('This is the log e of the original New P in the new p regime')
            # Y = log_Active_new_p_load
            # print(Y)
            # print('Emeka this is the corresponding simulated')
            # print(simulated)

            #Enhancing the model performanace but multi plying every coeficient in the
            # function by the ratio factor between the expected and the achieved
            last_display = []
            for elements in simulated:
                a = mean_dif + elements
                # a = elements
                last_display.append(a)

            for elements in range(0, len(last_display)):
                last_display[elements] = float(last_display[elements])

#             print("Predicted Y values for new Q and t: (not very good fit) - Natural log value")
#             print(last_display)
#             print(len(last_display))
#             print('\n')

            first_fit = []
            for elements in range(0, len(last_display)):
                real = e(last_display[elements])
                first_fit.append(real)

#             print('this is the first fit (Assumed to be bad) - Real Value')
#             print(first_fit)
#             print(len(first_fit))
#             print('\n')
            # print('this is original training Load')
            # print(load_final_1)
            # print(len(load_final_1))
            # print('\n')

            bulk_factor = 0
            over = 0
            pinch = 0
            pinchs = input('''What is the value of the distortion point:
Note: - if this is the first time you are running the code and do not know the distrotion point just put in 10
# ''')
            file_name = "distortion_point.txt"
                # Write to file (small predicted data)
            with open(file_name, "w") as file:
                file.write(f"{pinchs}\n")
            print(f"Numbers successfully written to {file_name}")
                
#             pinchs = 0
            store_input.append(pinchs)
            print(f'Distortion point = {pinchs}') 
            try:
                # print(f'pinchs = {pinchs}')
                pinch = float(pinchs)
            except:
                print('Put in a valid number for the distortion point')
                exit()
            
            if pinch > 0:
                for elements in range(0, len(Real_predicted_Y)):
                    if Real_predicted_Y[elements] > pinch:
                        factor = load_final_1[elements] / Real_predicted_Y[elements]
                        bulk_factor += factor
                        over += 1
                        # print(factor)

                bumpfactor = 1.25
                if over == 0:
                    mean_factor = 1
                else:
                    mean_factor = bulk_factor/over
#                     mean_factor = 1

                print('\n')
                print('mean_factor')
                print(mean_factor)
                print('\n')
                bump_up = []
                for elements in range(0, len(Real_predicted_Y)):
                    if Real_predicted_Y[elements] > pinch:
                        replace = Real_predicted_Y[elements] * mean_factor * bumpfactor
                        bump_up.append(replace)
                    else:
                        bump_up.append(Real_predicted_Y[elements])          
            
            
            
            #self calibrating                ########################################################################
                print('#################################################################################################################################################################################################################')
                total_ground_truth = 0
                total_predicted = 0
                mse_in = 0
                sse_in = 0
                MAX = 0
                MIN = 500
                for add in range(0, len(load_final_1)):        
                    total_ground_truth += load_final_1[add]
                    total_predicted += bump_up[add]
                    y = (total_ground_truth - total_predicted)**2
                    sse_in += y
                    if y**0.5 > MAX:
                        MAX = y
                    if y**0.5 < MIN:
                        MIN = y
                mse_in = sse_in/len(load_final_1)
                spans = MAX - MIN
                #                 lower_max_eff =
                print('total original')
                print(total_ground_truth)
                print('\n')
                print('total predicted')
                print(total_predicted)
                print('\n')
                print('precentage - (predicted to original)')
                percentage_match = total_predicted/total_ground_truth
                print(percentage_match)
                print('\n')
                properties = []
                properties.append(percentage_match)
                properties.append(spans)
                properties.append(mse_in)
                print('percentage             span gap                MSE')
                print(properties)
                
                a = load_final_1
                b = bump_up
                    
                plt.figure(figsize=(8, 5))
                plt.plot(a, marker='o', linestyle='-', label="Measured Data", color='b')
                plt.plot(b, marker='s', linestyle='--', label="Predicted Data (Smoothed)", color='r')

                # Labels and title
                plt.xlabel("Index")
                plt.ylabel("Value")
                plt.title("Comparison of Two Trends")
                plt.legend()
                plt.grid(True)
                
                
                a = []
                b = []
                c = 0
                d = 0
                for elements in load_final_1:
                    c += elements
                    a.append(c)
                    
                for elements in bump_up:
                    d += elements
                    b.append(d)
                    
                plt.figure(figsize=(8, 5))
                plt.plot(a, marker='o', linestyle='-', label="Measured Data", color='b')
                plt.plot(b, marker='s', linestyle='--', label="Predicted Data (Smoothed)", color='r')

                # Labels and title
                plt.xlabel("Index")
                plt.ylabel("Value")
                plt.title("Comparison of Two Trends")
                plt.legend()
                plt.grid(True)

                # Show the plot
                plt.show()
                print('#################################################################################################################################################################################################################')
                print('\n')                                 #   ########################################################################
                        
                        
                        
                print('This is the original data used for training')
                print(load_final_1)
                print(len(load_final_1))
                
                file_name = "original_load.txt"
                # Write to file
                with open(file_name, "w") as file:
                    for number in load_final_1:
                        file.write(f"{number}\n")
                print(f"Numbers successfully written to {file_name}")
                
                print('\n')
                print('This is the final brushup convert predicted')
                print(bump_up)
                print(len(bump_up))
                file_name = "predicted_training_load.txt"
                # Write to file
                with open(file_name, "w") as file:
                    for number in bump_up:
                        file.write(f"{number}\n")
                print(f"Numbers successfully written to {file_name}")
                print('\n')
                print('\n')
                better_trend = []
                for elements in bump_up:
                    better_trend.append(realog(elements))

#                 print('This is the better fit for the simulated old p- propped up fit - Natural log')
#                 print(better_trend)
                file_name = "log_predicted_load.txt"
                # Write to file (small predicted data)
                with open(file_name, "w") as file:
                    for number in better_trend:
                        file.write(f"{number}\n")
                print(f"Numbers successfully written to {file_name}")   
                print('\n')
                print(len(better_trend))
                print('\n')

                def e(x):
                    e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353
                    xx = e ** x
                    return (xx)

                last_display_real = []
                for elements in range(0, len(last_display)):
                    real = e(last_display[elements])
                    last_display_real.append(real)

                # print('last displayed real')
                # print(last_display_real)
                # print(len(last_display_real))
                # print('\n')
                new_p_bulk_factor = 0
                new_p_over = 0
                for elements in range(0, len(last_display_real)):
                    if last_display_real[elements] > pinch:
                        factor = Active_new_p_load[elements] / last_display_real[elements]
                        new_p_bulk_factor += factor
                        new_p_over += 1
                        # print(factor)

                if new_p_over == 0:
                    new_p_mean_factor = 1
                else:
                    new_p_mean_factor = new_p_bulk_factor/new_p_over
                print('\n')
                print('New P mean Factor')
                print(new_p_mean_factor)
                print('\n')
#                 print('Emeka, this is the last display')
#                 print(last_display)
#                 print('\n')
                new_p_bump_up = []
                for elements in range(0, len(last_display_real)):
                    if last_display_real[elements] > pinch:
                        replace = last_display_real[elements] * new_p_mean_factor * bumpfactor
                        new_p_bump_up.append(replace)
                    else:
                        new_p_bump_up.append(last_display_real[elements])
                                      
                print('Original New active P')
                print(Active_new_p_load)
                print(len(Active_new_p_load))
                print('\n')
                print('This is the original new active P')
                for elements in Active_new_p_load:
                    print(elements)
                print('\n')
                print('This is the drainage discharge for the smaller data set')
                for number in range(0, len(Active_new_p_discharge)):
                        print(Active_new_p_discharge[number])
                print('\n')
                file_name = "original_smaller_set_load.txt"
                # Write to file
                with open(file_name, "w") as file:
                    for number in Active_new_p_load:
                        file.write(f"{number}\n")
                print(f"Numbers successfully written to {file_name}")
                print('\n')
                print('Predicted Old P in the New P regime')
                print(new_p_bump_up)
                print(len(new_p_bump_up))
                print('\n')
                print('This is the final smaller load set prediction')
                for elementss in new_p_bump_up:
                    print(elementss)
                print('\n')
                #writing the predicted load to the txt file load_predictor.txt
                file_name = "load_predictor.txt"
                # Write to file (small predicted data only)
                with open(file_name, "w") as file:
                    for number in new_p_bump_up:
                        file.write(f"{number}\n")
                print(f"Numbers successfully written to {file_name}")   
                print('\n')

                file_name = "load_predictor1.txt"
                # Write to file (small predicted Flow and time)
                with open(file_name, "w") as file:
                    for number in range(0, len(Active_new_p_discharge)):
                        a = Active_new_p_discharge[number]
                        b = new_p_time[number]
                        file.write(f"{a}	{b}	0\n")
                print(f"Numbers successfully written to {file_name}")
                print('\n')
                
                file_name = "load_predictor2.txt"
                # Write to file (flow and zero)
                with open(file_name, "w") as file:
                    for number in Active_new_p_discharge:
                        file.write(f"{number}	0\n")
                print(f"Numbers successfully written to {file_name}")
                print('\n')
                
                file_name = "predicted_training_flow_time_load.txt"
                # Write to file
                with open(file_name, "w") as file:
                    for number in range(0, len(flow_final_1)):
                        a = flow_final_1[number]
                        b = time_final_1[number]
                        c = bump_up[number]
                        file.write(f"{a}	{b}	{c}\n")
                            
                print(f"Numbers successfully written to {file_name}")
                print('\n')
                
                file_name = "predicted_training_flow_load.txt"
                # Write to file
                with open(file_name, "w") as file:
                    for number in range(0, len(flow_final_1)):
                        a = flow_final_1[number]
                        c = bump_up[number]
                        file.write(f"{a}	{c}\n")
                print(f"Numbers successfully written to {file_name}")
                print('\n')
                
                file_name = "new_small_pred_load_time.txt"
                # Write to file
                with open(file_name, "w") as file:
                    for number in range(0, len(new_p_bump_up)):
                        a = new_p_bump_up[number]
                        b = new_p_time[number]
                        c = Active_new_p_discharge[number]
                        file.write(f"{a}	{b}	{c}\n")
                
                Y_pred_full = model.predict(X)
                # print('\n')
                # print(f'The system\'s predicted Y is of the data type {type(Y_pred_full)} ')
                # print('\n')
                plt.figure(figsize=(10, 6))
                plt.plot(Y, label='Actual Y', marker='o')
                plt.plot(Y_pred_full, label='Predicted Y', marker='x')
                plt.xlabel('Data Points')
                plt.ylabel('Y Values')
                plt.legend()
                plt.title('Actual vs Predicted Y Values')
                plt.show()

                field = input('''What field and nutrient are you running for: 
                Answer should be in the form of Field-Nutrient e:g organic-DRP
                ''')
                store_input.append(field)

                Y_pred_full = np.array(better_trend)
                # print('\n')
                # print(f'The system\'s predicted Y is of the data type {type(Y_pred_full)} ')
                # print('\n')
                plt.figure(figsize=(10, 6))
                plt.plot(Y, label='Actual Y', marker='o')
                plt.plot(Y_pred_full, label='Predicted Y', marker='x')
                plt.xlabel('Data Points')
                plt.ylabel('Ln Nutrient losses (kg/ha)')
                plt.legend()
                plt.title(f'{field} Simulated and Real Nutrient losses')
                plt.show()

#             else:
#                 print(f'the Event cut off = {pinch}')

            print('\n')
            print("Event Flow Model coefficients:")
            aaa = f"{model.coef_[0] * mean_factor * bumpfactor}"
            bbb = f"{model.coef_[1] * mean_factor * bumpfactor}"
            ccc = f"{model.coef_[2] * mean_factor * bumpfactor}"
            ddd = f"{model.intercept_ * mean_factor * bumpfactor}"
            print(f"β1: {model.coef_[0] * mean_factor * bumpfactor}")
            print(f"β2: {model.coef_[1] * mean_factor * bumpfactor}")
            print(f"β3: {model.coef_[2] * mean_factor * bumpfactor}")
            print(f"β0: {model.intercept_ * mean_factor * bumpfactor}")
            print(f'mean Factor * bump factor = {mean_factor * bumpfactor}')
            
            for elements in range(0, 4):
                if elements < 4:
                    if elements == 0:
                        coefs_.append(aaa)
                    elif elements == 1:
                        coefs_.append(bbb)
                    elif elements == 2:
                        coefs_.append(ccc)
                    else:
                        coefs_.append(ddd)
            
#             print('\n')
#             print('These are the coefficients')
#             print(coefs_)
#             print('\n')
            
            file_name = "Coefficients.txt"
            # Write to file
            with open(file_name, "w") as file:
                for number in coefs_:
                    file.write(f"{number}\n")
            print(f"Numbers successfully written to {file_name}")
            print('\n')
            print('\n')
            
            print('This is the chronology of your response')
            print('\n')
            for elements in store_input:
                print(elements)


    if used_frame == 0:
        used_frame += 1
        new_regime = fet_application()
    #         print(f'This is the list you seek Emeka {new_regime}')
    if used_frame == 1:
        take_off_bar = []
        for elements in new_regime:
            if elements != '-':
                take_off_bar.append(elements)
        new_regime = take_off_bar
        # print('This is the new_regime')
        # print(new_regime)
        used_frame += 1
        fit_data()
        
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
####################################################################################################################################################################################################################################
        
    print('\n')
    print('''#######################################################################################################################################
#######################################################################################################################################
#######################################################################################################################################
    ''')
    

# concentration comes second
    print('\n')
    a = open('load_conc.txt', 'r')
    b = []

    for lines in a:
        #c = we strip the lines with c, making every line an item
        c = lines.strip()
        d = lines.split()
        b.append(d)
    a.close()

    Concentration = []
    Load = []
    #this part of the code checks for single data on one isle and none on the other
    for elements in range(0, len(b)):
    #     print(b[elements])
    #     print(len(b[elements]))
        if len(b[elements]) < 2:
    #         print(elements + 1)
            if datatype == 'y':
                b[elements] = [' ', ' ']
            else:
                b[elements] = ['0', '0']
        Concentration.append(b[elements][1])
        Load.append(b[elements][0])
#     print(Concentration)
#     print(Load)

    # Example data
    # Concentration = ['0.058', '0.024', '0.025', '0.027', '0.04', '0.029', '0.032', '0.044', '0.024', '0.028', '0.028', '0.026', '0.025', '0.027', '0.029', '0.035', '0.037', '0.076', '0.436', '0.096', '3.429', '0.489', '0.198', '0.107', '0.09', '0.432', '5.383', '6.075', '2.805', '2.657', '0.579', '0.265', '0.188', '0.112', '0.1', '0.139', '0.117', '0.094', '0.103', '0.095', '0.42', '0.153', '0.089', '0.081', '0.081', '0.093', '0.079', '0.086', '0.095', '0.386', '0.332', '0.141', '0.122', '0.262', '0.31', '0.109', '0.073', '0.174', '0.115', '0.08', '0.526', '0.244', '0.06', '0.054', '0.055', '0.057', '0.061', '0.086', '0.075', '0.076', '0.274', '0.056', '0.118', '0.038', '0.029', '0.215', '0.062', '0.187', '0.075', '0.053', '0.055', '0.059', '0.059', '0.071', '0.241', '0.2', '0.179', '0.065', '0.245', '0.233', '0.134', '0.173', '0.077', '0.028', '0.018', '0.108', '0.032', '0.024', '0.351', '0.387', '0.126', '0.482', '0.599', '0.11', '0.037', '0.035', '0.078', '0.038', '0.182', '0.052', '0.042', '0.068', '0.084', '0.057', '0.267', '0.134', '0.102', '0.41', '0.185', '0.068', '0.059', '0.057', '0.041', '0.041', '0.058', '0.121', '0.081', '0.262', '0.485', '0.124', '0.095', '0.208', '0.259', '0.265', '0.063', '0.053', '0.054', '0.076', '0.052', '0.052', '0.033', '0.052', '0.056', '0.038', '0.04', '0.193', '0.063', '0.045', '0.045', '0.159', '0.047', '0.043', '0.338', '0.059', '0.054', '0.047', '0.051', '2.227', '5.748', '1.692', '0.334', '0.286', '0.137', '0.1', '0.091', '2.374', '2.268', '0.385', '0.203', '0.14', '0.164', '0.221', '0.105', '0.222', '0.369', '0.189', '0.192', '0.125', '0.098', '0.356', '0.076', '0.082', '0.076', '0.087', '0.06', '0.085', '0.072', '0.072', '0.072', '0.065', '0.156', '0.087', '0.067', '0.247', '0.247', '0.247', '0.191', '0.096', '0.103', '0.075', '0.072', '0.07', '0.07', '0.074', '0.073', '0.073', '0.069', '0.075', '0.087', '0.067', '0.075', '0.088', '0.107', '0.328', '0.073', '0.067', '0.069', '0.064', '0.065', '0.145', '0.143', '0.461', '0.385', '0.143', '0.14', '0.139', '0.136', '0.133', '0.135', '0.239', '0.138', '0.087', '0.335', '0.072', '0.067', '0.067', '0.068', '0.063', '0.065', '0.062', '0.063', '0.046', '0.066', '0.045', '0.034', '0.042', '0.033', '0.029', '0.75', '0.06', '0.04', '0.02', '0.03', '0.03', '0.03', '0.026', '0.046', '0.039', '0.035', '0.032', '0.786', '0.078', '0.125', '0.965', '0.633', '0.13', '0.058', '0.07', '0.062', '0.068', '0.066', '0.07', '0.083', '0.28', '0.088', '0.06', '0.107', '0.074', '0.067', '0.077', '0.134', '0.104', '0.084', '0.09', '0.084', '0.088', '0.094', '0.084', '0.045', '0.098', '0.177', '0.054', '0.129', '0.109', '0.129', '0.139', '0.127', '0.082', '0.144', '0.104', '0.088', '0.079', '0.1', '0.107', '0.122', '0.073', '0.127', '0.139', '0.205', '0.539', '0.16', '0.115', '0.094', '0.059', '0.063', '0.058', '0.06', '0.053', '0.054', '0.057', '0.067', '0.072', '0.069', '0.028', '0.029', '0.031', '0.026', '0.024', '0.027', '0.03', '0.032', '0.033', '0.033', '0.031', '0.048', '0.033', '0.275', '0.156', '0.09', '0.053', '0.045', '0.037', '0.033', '0.027', '0.029', '0.207', '0.085', '0.039', '0.066', '0.183', '0.188', '0.382', '0.198', '0.044', '0.042', '0.041', '0.034', '0.306', '0.09', '0.044', '0.041', '0.038', '0.037', '0.039', '0.035', '0.057', '0.126', '0.259', '0.078', '0.062', '0.045', '0.04', '0.053', '0.106', '0.173', '0.051', '0.034', '0.043', '0.046', '0.05', '0.05', '0.024', '0.036', '0.022', '0.041', '0.042', '0.037', '0.035', '0.124', '0.27', '0.843', '0.581', '0.806', '0.143', '0.066', '0.035', '0.033', '0.052', '0.053', '0.048', '0.048', '0.045', '0.045', '0.046', '0.045', '0.045', '0.048', '0.044', '0.042', '0.041', '0.047', '0.037', '0.045', '0.032', '0.046', '0.037', '0.043', '0.039', '0.043', '0.252', '0.578', '0.075', '0.063', '0.05', '0.048', '0.071', '0.062', '0.05', '0.051', '0.05', '0.049', '0.048', '0.045', '0.043', '0.113', '0.063', '0.049', '0.047', '0.048', '0.043', '0.041', '0.042', '0.037', '0.048', '0.022', '0.022', '0.017', '0.017', '0.017', '0.024', '0.04', '0.033', '0.03', '0.042', '0.039', '0.046', '0.028', '0.06', '0.092', '0.03', '0.009', '0.077', '0.078', '0.026', '0.063', '0.078', '0.036', '0.056', '0.039', '0.105', '0.401', '0.051', '0.07', '0.055', '0.064', '0.363', '0.046', '0.029', '0.027', '0.032', '0.046', '0.04', '0.042', '0.06', '0.345', '0.063', '0.269', '0.357', '0.084', '0.065', '0.078', '0.154', '0.393', '0.109', '0.062', '0.069', '0.103', '0.077', '0.128', '0.07', '0.097', '0.08', '1.32', '0.212', '0.113', '0.099', '0.341', '0.091', '0.093', '0.209', '0.365', '0.114', '0.075', '0.266', '0.361', '0.099', '0.085', '0.082', '0.234', '0.258', '0.228', '0.124', '0.095', '0.048', '0.039', '0.041', '0.042', '0.599', '0.375', '0.06', '0.048', '0.308', '0.132', '0.046', '0.043', '0.041', '0.048', '0.036', '0.034', '0.032', '0.033', '0.036', '0.031', '0.036', '0.039', '0.038', '0.044', '0.066', '0.034', '0.044', '0.037', '0.029', '0.032', '0.034', '0.056', '0.047', '0.027', '0.152', '0.132', '0.031', '0.086', '0.443', '0.117', '0.033', '0.056', '0.049', '0.102', '0.071', '0.072', '0.077', '0.091', '0.147', '0.073', '0.123', '0.088', '0.073', '0.235', '0.127', '0.968', '0.647', '0.156', '0.202', '0.092', '0.091', '0.097', '0.102', '0.104', '0.104', '0.104', '0.104', '0.104', '0.104', '4.266', '2.455', '0.735', '0.71', '0.282', '0.209', '0.186', '1.709', '3.959', '1.732', '1.568', '2.912', '4.769', '1.823', '0.407', '1.7', '0.498', '0.384', '0.65', '0.234', '0.169', '0.126', '0.098', '0.984', '0.168', '0.171', '0.683', '0.15', '0.061', '0.075', '0.062', '0.058', '0.068', '0.066', '0.068', '0.045', '0.038', '0.043', '0.025', '0.044', '0.039', '0.049', '0.034', '0.036', '0.04', '0.044', '0.055', '0.056', '0.036', '0.037', '0.04', '0.087', '0.395', '0.083', '0.527', '0.064', '0.056', '0.051', '0.056', '0.049', '0.064', '0.049', '0.079', '0.022', '0.07', '0.064', '0.055', '0.05', '0.051', '0.055', '0.335', '0.063', '0.229', '0.058', '0.058', '0.03', '0.077', '0.07', '0.058', '0.03', '0.034', '0.038', '0.041', '0.064', '0.094', '0.793', '0.787', '0.06', '0.063', '0.084', '0.452', '0.144', '0.171', '0.074', '0.068', '0.064', '0.065', '0.063', '0.049', '0.047', '0.041', '0.042', '0.04', '0.05', '0.053', '0.066', '0.057', '0.051', '0.049', '0.059', '0.052', '0.048', '0.044', '0.071', '0.052', '0.055', '0.05', '0.048', '0.045', '0.045', '0.025', '0.023', '0.099', '0.238', '0.091', '0.066', '0.048', '0.039', '0.045', '0.03', '0.028', '0.026', '0.024', '0.022', '0.015', '0.02', '0.017', '0.018', '0.019', '0.46', '0.179', '0.229', '0.774', '0.228', '0.131', '0.106', '0.086', '0.081', '0.071', '0.128', '0.115', '0.081', '0.054', '0.075', '0.049', '0.105', '0.076', '0.616', '0.223', '0.07', '0.049', '0.049', '0.042', '0.038', '0.039', '0.035', '0.042', '0.036', '0.037', '0.025', '0.034', '0.239', '1.311', '0.535', '0.114', '0.073', '0.07', '0.089', '0.076', '0.043', '0.053', '0.045', '0.047', '0.043', '0.046', '0.424', '1.074', '0.158', '0.079', '0.07', '0.687', '1.101', '0.175', '0.063', '0.057', '0.077', '0.442', '0.511', '0.608', '0.115', '0.062', '0.05', '0.098', '0.076', '0.074', '0.062', '0.109', '0.116', '0.106', '0.108', '0.078', '0.111', '0.072', '0.061', '0.044', '0.058', '0.169', '0.074', '0.158', '0.045', '0.047', '0.04', '0.389', '0.872', '0.203', '0.063', '0.072', '0.051', '0.045', '0.057', '0.058', '0.041', '0.045', '0.035', '0.034', '0.035', '0.034', '0.032', '0.027', '0.091', '0.076', '0.028', '0.055', '0.021', '0.028', '0.02', '0.019', '0.016', '0.069', '0.014', '0.012', '0.029', '0.104', '0.028', '0.027', '0.02', '0.023', '0.019', '0.018', '0.025', '0.025', '0.018', '0.029', '0.018', '0.103', '0.07', '0.029', '0.016', '0.048', '0.018', '0.058', '0.028', '0.027', '0.035', '0.027', '0.03', '0.025', '0.027', '0.025', '0.025', '0.028', '0.036', '0.033', '0.036', '0.035', '0.052', '0.02', '0.039', '0.17', '0.17', '0.403', '0.173', '0.113', '0.089', '0.073', '0.067', '0.072', '0.087', '0.073', '0.062', '0.066', '0.082', '0.07', '0.066', '0.062', '0.055', '0.055', '0.053', '0.051', '0.05', '0.152', '0.315', '0.13', '0.489', '0.092', '0.082', '0.084', '0.08', '0.087', '0.074', '0.135', '0.096', '0.099', '0.09', '0.071', '0.075', '0.06', '0.068', '0.056', '0.055', '0.056', '0.064', '0.075', '0.068', '0.067', '0.055', '0.053', '0.054', '0.051', '0.084', '0.044', '0.034', '0.027', '0.04', '0.037', '0.063', '0.144', '0.093', '0.06', '0.075', '0.034', '0.115', '0.059', '0.039', '0.046', '0.041', '0.07', '0.061', '0.527', '0.375', '0.119', '0.076', '0.089', '0.066', '0.059', '0.078', '0.047', '0.05', '0.043', '0.043', '0.042', '0.054', '0.079', '0.288', '0.843', '1.281', '1.019', '0.782', '0.176', '0.098', '0.092', '0.094', '0.06', '0.072', '0.062', '0.054', '0.055', '0.043', '0.045', '0.061', '0.058', '0.06', '0.064', '0.066', '0.051', '0.053', '0.059', '0.067', '0.058', '0.053', '0.057', '0.065', '0.055', '0.051', '0.046', '0.046', '0.05', '0.088', '0.088', '0.029', '0.027', '0.034', '0.03', '0.033', '0.036', '0.035', '0.038', '0.131', '0.412', '0.331', '0.159', '0.072', '0.05', '0.495', '0.11', '0.108', '0.139', '0.05', '0.089', '0.112', '0.083', '0.089', '0.088', '0.089', '0.058', '0.071', '0.072', '0.027', '0.04', '0.056', '0.051', '0.235', '0.82', '0.413', '0.144', '0.109', '0.079', '0.066', '0.063', '0.062', '0.2', '0.162', '0.096', '0.06', '0.054', '0.055', '0.16587', '0.10725', '0.09715', '0.0467', '0.08835', '0.07865', '0.06143', '0.12579', '0.078', '0.213', '0.29', '0.076', '0.21', '0.086', '0.075', '0.077', '0.051', '0.065', '0.074', '0.071', '0.232', '0.099', '0.087', '0.456', '0.107', '0.07']


    # Load = ['0.001682645', '0.000366755', '0.000294604', '0.000238645', '0.000394649', '0.000270936', '0.000288623', '0.000326033', '0.00014547', '0.000155444', '0.000137267', '0.000112404', '0.00010518', '9.20E-05', '9.98E-05', '9.88E-05', '0.000119048', '0.00018303', '0.017976484', '0.000971278', '0.036578725', '0.003374039', '0.000808861', '0.000264269', '0.00016177', '0.000795725', '0.118091942', '0.13221325', '0.020675039', '0.014767283', '0.021369358', '0.007331026', '0.003045041', '0.000875374', '0.000780314', '0.00176606', '0.001427221', '0.000756235', '0.000653917', '0.000591935', '0.044922858', '0.011141198', '0.002729671', '0.001748121', '0.001251603', '0.00109452', '0.000843661', '0.000592233', '0.000496996', '0.004973839', '0.008121027', '0.00231614', '0.001289878', '0.011347457', '0.021243497', '0.006758643', '0.000771473', '0.007125863', '0.004765837', '0.005293731', '0.081976906', '0.015919502', '0.002311059', '0.000480553', '0.000437543', '0.000304558', '0.000212959', '0.00037338', '0.000362886', '0.000335555', '0.00137211', '0.000475706', '0.001917276', '0.00046695', '0.001306033', '0.007233201', '0.00140348', '0.015083168', '0.001602029', '0.000352092', '0.002400254', '0.001269732', '0.000815977', '0.000687961', '0.001687444', '0.001331204', '0.003197904', '0.000539941', '0.004529306', '0.004907988', '0.000659558', '0.000746686', '0.000250433', '6.50E-05', '3.72E-05', '0.000579037', '0.000110094', '4.52E-05', '0.000519293', '0.0004764', '0.000891188', '0.013820369', '0.004698499', '0.000124659', '2.30E-05', '2.14E-05', '2.74E-05', '3.47E-05', '0.000146493', '1.96E-05', '8.95E-06', '1.82E-05', '1.70E-05', '6.02E-06', '0.000417155', '0.004862955', '0.000970531', '0.055037422', '0.007582618', '0.000980561', '0.000461671', '0.000180419', '7.38E-05', '8.35E-05', '0.000196569', '0.000149971', '7.74E-05', '0.007429571', '0.066445627', '0.004486056', '0.001935625', '0.005490465', '0.032068483', '0.032650583', '0.002249233', '0.001105207', '0.000585198', '0.000556273', '0.000173206', '0.000907519', '0.000406736', '0.00035288', '0.001689558', '0.000723832', '0.000604282', '0.008488286', '0.001915304', '0.000398043', '0.000341161', '0.002953864', '0.000776959', '0.000395431', '0.003000045', '0.00045502', '0.000299693', '0.000213051', '0.000189584', '0.146674817', '0.855709811', '0.079240996', '0.007782276', '0.005176646', '0.001455125', '0.000618288', '0.000505016', '0.292817705', '0.303152813', '0.01638106', '0.006160446', '0.002203251', '0.002412171', '0.002584262', '0.000816463', '0.005521273', '0.018971938', '0.00702453', '0.00621349', '0.003823547', '0.002426631', '0.010336851', '0.000728041', '0.000631962', '0.000912317', '0.001187279', '0.00046297', '0.000499586', '0.000373761', '0.000347891', '0.000347862', '0.000304214', '0.000685477', '0.000477453', '0.000364828', '0.001229166', '0.001160768', '0.001006111', '0.009454162', '0.002377283', '0.001804146', '0.000995473', '0.000772483', '0.000690017', '0.000619', '0.0007872', '0.000840221', '0.000785297', '0.000595486', '0.00050728', '0.000564495', '0.000441841', '0.000442873', '0.000708299', '0.004314631', '0.018671566', '0.001785482', '0.001173062', '0.001216109', '0.001241676', '0.001005529', '0.001885756', '0.001764428', '0.036855562', '0.023482596', '0.004042587', '0.002711554', '0.002001457', '0.001596713', '0.001373705', '0.001188732', '0.001781889', '0.000962418', '0.000614856', '0.020923579', '0.001848146', '0.001095316', '0.000816495', '0.00071734', '0.000659811', '0.000588975', '0.000538315', '0.000450027', '0.000326526', '0.001266432', '0.001011753', '0.000550881', '0.000511017', '0.000304409', '0.000272887', '0.007098813', '0.000966663', '0.000999896', '0.00032742', '0.000396076', '0.000365481', '0.000360536', '0.000362408', '0.000390889', '0.000235827', '0.00015519', '0.0001029', '0.072365702', '0.002500667', '0.002969097', '0.118357914', '0.09590025', '0.007462374', '0.001695265', '0.001408311', '0.00094634', '0.000844615', '0.00066949', '0.000632976', '0.000817759', '0.007708413', '0.001910776', '0.000459106', '0.000695745', '0.000607416', '0.000444517', '0.000445683', '0.002825982', '0.002650572', '0.001133195', '0.001179957', '0.000913764', '0.000570155', '0.000482236', '0.000319606', '0.000139137', '0.000247438', '0.001265971', '0.000256064', '0.000381242', '0.000188681', '0.000165369', '0.000451193', '0.000403557', '9.29E-05', '0.000984598', '0.000295944', '1.00E-04', '6.77E-05', '4.45E-05', '4.14E-05', '9.91E-05', '3.70E-05', '3.54E-05', '1.55E-05', '0.008061574', '0.062187692', '0.002690109', '0.000724281', '0.000195844', '4.65E-05', '3.21E-05', '2.64E-05', '4.56E-05', '2.74E-05', '1.86E-05', '1.78E-05', '4.33E-05', '3.84E-05', '2.53E-05', '1.56E-05', '1.35E-05', '1.16E-05', '8.15E-06', '6.93E-06', '3.53E-07', '7.80E-06', '8.84E-06', '1.09E-05', '8.05E-06', '6.49E-06', '1.27E-05', '1.09E-05', '0.003104193', '0.001182567', '0.000646909', '9.80E-05', '5.97E-05', '3.20E-05', '2.70E-05', '2.43E-05', '2.55E-05', '0.000521533', '0.000181554', '4.15E-05', '0.00012802', '0.001983608', '0.001893938', '0.012386984', '0.008230461', '0.000410961', '0.000253385', '0.000156393', '0.000109597', '0.010907291', '0.002062177', '0.000604978', '0.000202013', '0.000148438', '0.000185009', '0.00018544', '0.000103547', '0.000207691', '0.001219236', '0.003261529', '0.000701813', '0.000395959', '0.000339801', '0.000214388', '0.000378464', '0.000902348', '0.00299595', '0.000921386', '0.000356511', '0.000271376', '0.000167', '0.000108', '7.55E-05', '4.24E-05', '5.83E-05', '2.48E-05', '4.20E-05', '4.88E-05', '3.32E-05', '3.93E-05', '0.000365963', '0.008121398', '0.037591293', '0.015321294', '0.049061367', '0.005382322', '0.001857685', '0.000531437', '0.000373675', '0.000462373', '0.000411887', '0.000322552', '0.00026156', '0.00022502', '0.000194781', '0.000197', '0.000171', '0.000149', '0.000141', '0.000124', '0.000116', '0.00011', '0.000111', '9.24E-05', '7.56E-05', '5.35E-05', '8.93E-05', '8.21E-05', '9.74E-05', '9.02E-05', '8.42E-05', '0.017358173', '0.075641737', '0.002365454', '0.001113269', '0.000594338', '0.000416', '0.000470097', '0.000362525', '0.000237615', '0.000226856', '0.000199524', '0.000178', '0.000176', '0.000139', '0.000157', '0.002503377', '0.001049283', '0.000510738', '0.000376335', '0.000325817', '0.000236627', '0.000183', '0.000171', '0.000147', '0.000157', '6.80E-05', '6.62E-05', '4.68E-05', '4.79E-05', '4.57E-05', '5.01E-05', '0.000101', '7.65E-05', '5.84E-05', '0.000296574', '0.000171', '0.000101', '4.22E-05', '7.51E-05', '9.66E-05', '3.27E-05', '1.17E-05', '4.98E-05', '0.000108', '1.86E-05', '4.70E-05', '4.21E-05', '8.99E-06', '7.54E-05', '3.52E-05', '0.000707196', '0.047509465', '0.001236231', '0.000755678', '0.000383', '0.000608489', '0.042879259', '0.00132516', '0.000403609', '0.000238791', '0.000208046', '0.00023', '0.000141', '5.79E-05', '6.24E-05', '0.023268305', '0.001016787', '0.03107773', '0.009157866', '0.001060527', '0.000235', '0.000857833', '0.003642711', '0.049541722', '0.002731408', '0.000688474', '0.000211', '0.000167', '8.30E-05', '7.11E-05', '4.95E-05', '7.92E-05', '3.63E-05', '0.076659046', '0.008785306', '0.001449055', '0.001019785', '0.002458713', '0.000495', '0.000543429', '0.009418168', '0.032433903', '0.006706092', '0.001596885', '0.017299333', '0.040975894', '0.003289028', '0.001839453', '0.001316934', '0.002583975', '0.009509396', '0.010454959', '0.003004006', '0.001397578', '0.00032434', '0.000211882', '0.000192792', '0.000558515', '0.093814803', '0.038273282', '0.001716274', '0.000917862', '0.024864272', '0.0096059', '0.001233712', '0.000721725', '0.00049187', '0.000426481', '0.000255938', '0.000130528', '0.000110036', '8.75E-05', '8.42E-05', '7.24E-05', '7.79E-05', '0.000101224', '0.000111836', '0.00010173', '0.000189474', '9.75E-05', '0.000228552', '0.000333398', '0.000216821', '0.000222294', '0.000314657', '0.000748686', '0.000817058', '0.000220277', '0.005794915', '0.010596408', '0.000727527', '0.001454034', '0.060822754', '0.004604546', '0.000624821', '0.000750355', '0.000622827', '0.000938606', '0.001302854', '0.001297902', '0.00060406', '0.000731827', '0.004961771', '0.001944915', '0.004797772', '0.002904085', '0.001238516', '0.002096841', '0.000602473', '0.004224702', '0.002146043', '0.000498655', '0.000722193', '0.000317129', '0.000258723', '0.000123501', '0.000104127', '0.000129554', '0.000113538', '0.000112621', '0.000114166', '9.32E-05', '0.000107771', '0.007865605', '0.002723926', '0.000630015', '0.000761683', '0.000256862', '0.000257929', '0.000249737', '0.006027265', '0.055130505', '0.010503043', '0.005970585', '0.022768514', '0.214321694', '0.044627769', '0.002269367', '0.01266797', '0.002727554', '0.003187083', '0.016947805', '0.003972665', '0.001682388', '0.000712248', '0.000677538', '0.090519315', '0.006446475', '0.002829861', '0.059938714', '0.009663491', '0.001791324', '0.000663415', '0.000494003', '0.000308505', '0.000650321', '0.000845928', '0.00102837', '0.000902709', '0.000561712', '0.000280249', '0.000169609', '0.000318894', '0.000190437', '0.000196309', '0.000136877', '0.000132096', '0.000177911', '0.00019971', '0.000362672', '0.000383798', '0.000213321', '0.000188231', '0.000183597', '0.00038429', '0.018961886', '0.001676944', '0.034183594', '0.002896548', '0.000373119', '0.000298373', '0.000292301', '0.000240709', '0.000294809', '0.000226964', '0.000319038', '9.59E-05', '0.00049718', '0.000393193', '0.000246989', '0.000189502', '0.000173994', '0.000188695', '0.001220532', '0.000457999', '0.006465317', '0.00208019', '0.001030131', '0.000355709', '0.000694056', '0.000530622', '0.000370247', '0.000162642', '0.000155944', '0.000156775', '0.000160115', '0.000461316', '0.00082787', '0.01279317', '0.008651084', '0.000477736', '0.000394365', '0.000606232', '0.053808034', '0.004194294', '0.003222009', '0.00092963', '0.000522373', '0.000349154', '0.000275111', '0.000268842', '0.000196362', '0.000151276', '0.000108338', '0.000100691', '8.70E-05', '9.16E-05', '6.15E-05', '2.76E-05', '2.27E-05', '1.81E-05', '1.63E-05', '1.74E-05', '1.20E-05', '1.07E-05', '2.32E-05', '5.98E-05', '4.28E-05', '4.13E-05', '3.57E-05', '3.53E-05', '3.04E-05', '2.71E-05', '1.48E-05', '1.35E-05', '0.000106268', '0.001539007', '0.000372281', '0.00010244', '6.73E-05', '4.34E-05', '4.35E-05', '2.71E-05', '2.31E-05', '1.81E-05', '1.16E-05', '6.73E-06', '3.31E-06', '3.44E-06', '2.02E-06', '1.27E-06', '4.50E-07', '0.002207843', '0.000128084', '8.74E-05', '0.020743386', '0.003014077', '0.000825087', '0.000436924', '0.000244549', '0.000190677', '0.000134242', '0.000188362', '0.000129621', '8.06E-05', '4.09E-05', '4.20E-05', '3.13E-05', '8.66E-05', '0.000103928', '0.023523136', '0.005020015', '0.000745113', '0.000379511', '0.000282399', '0.000200284', '0.000233213', '0.000188309', '0.000179608', '0.000191287', '0.000177811', '0.000207217', '0.000121962', '0.00036446', '0.003703539', '0.155208248', '0.032436613', '0.002315537', '0.001038293', '0.000734954', '0.00071495', '0.000476158', '0.000234776', '0.000226094', '0.000169862', '0.000191933', '0.000147177', '0.000141163', '0.016295676', '0.161348637', '0.00680332', '0.001764212', '0.00114132', '0.060016957', '0.136398554', '0.006042904', '0.001300954', '0.000946466', '0.001103545', '0.02950309', '0.058799603', '0.08746054', '0.005021854', '0.00160574', '0.000996043', '0.002159048', '0.002162272', '0.00188844', '0.001386439', '0.002056696', '0.001894898', '0.001882555', '0.001559916', '0.000792215', '0.000920769', '0.00049355', '0.000401292', '0.000297685', '0.000424026', '0.003573774', '0.001297276', '0.002974804', '0.000691242', '0.000578171', '0.000373082', '0.01381447', '0.131222174', '0.010648916', '0.001676038', '0.001326573', '0.000707921', '0.000477345', '0.000498072', '0.000423129', '0.000250215', '0.000237564', '0.000171113', '0.000149676', '0.000129458', '0.000108911', '9.06E-05', '7.48E-05', '0.000231365', '0.000145707', '4.70E-05', '9.09E-05', '3.30E-05', '4.37E-05', '2.63E-05', '2.28E-05', '1.96E-05', '7.87E-05', '1.59E-05', '1.57E-05', '4.22E-05', '0.000206931', '4.50E-05', '3.52E-05', '2.18E-05', '2.30E-05', '2.07E-05', '1.72E-05', '2.00E-05', '1.59E-05', '1.05E-05', '1.69E-05', '9.37E-06', '5.05E-05', '3.33E-05', '1.67E-05', '7.98E-06', '2.38E-05', '8.47E-06', '2.67E-05', '1.33E-05', '1.18E-05', '1.52E-05', '1.24E-05', '1.40E-05', '1.08E-05', '1.05E-05', '9.49E-06', '9.44E-06', '5.89E-06', '4.87E-06', '3.44E-06', '2.88E-06', '1.66E-06', '7.92E-07', '1.17E-06', '8.45E-06', '4.68E-05', '0.000169347', '0.000621749', '6.76E-05', '2.77E-05', '1.71E-05', '1.13E-05', '1.16E-05', '1.63E-05', '2.17E-05', '1.50E-05', '1.30E-05', '1.30E-05', '1.44E-05', '9.50E-06', '7.14E-06', '6.57E-06', '3.03E-06', '2.97E-06', '3.49E-06', '1.93E-06', '3.82E-07', '0.001704904', '0.012386289', '0.00112368', '0.026056536', '0.001434928', '0.000624505', '0.000297351', '0.000110603', '4.85E-05', '3.00E-05', '0.000470259', '0.000196394', '0.000133374', '0.000115014', '7.01E-05', '5.61E-05', '4.09E-05', '3.99E-05', '3.43E-05', '3.33E-05', '2.89E-05', '4.03E-05', '4.24E-05', '3.22E-05', '2.94E-05', '2.09E-05', '2.05E-05', '2.31E-05', '2.12E-05', '3.49E-05', '1.58E-05', '1.03E-05', '7.26E-06', '1.04E-05', '4.56E-06', '7.37E-06', '3.02E-05', '1.77E-05', '6.12E-06', '3.49E-06', '3.74E-06', '5.25E-05', '2.06E-05', '9.78E-06', '6.43E-06', '4.90E-06', '7.28E-06', '2.93E-06', '0.019648306', '0.019639924', '0.002229762', '0.001112402', '0.000930749', '0.000600247', '0.000438662', '0.00048635', '0.000224406', '0.000192093', '0.000133539', '9.84E-05', '7.29E-05', '0.000110419', '0.000415712', '0.006341226', '0.058234988', '0.20071042', '0.153645621', '0.100112236', '0.011227023', '0.002956244', '0.002662562', '0.002763366', '0.00112814', '0.00104931', '0.000721886', '0.000492619', '0.000411111', '0.000292824', '0.000290575', '0.000346046', '0.000275094', '0.000238536', '0.000246082', '0.000199249', '0.000133496', '0.000183131', '0.000160239', '0.000174792', '0.000162281', '0.000108729', '0.000108828', '0.000141381', '0.000130847', '0.000116868', '7.61E-05', '8.19E-05', '9.05E-05', '0.000185859', '0.00016099', '3.40E-05', '3.71E-05', '4.91E-05', '4.35E-05', '4.72E-05', '5.21E-05', '4.54E-05', '4.47E-05', '0.000215272', '0.014975777', '0.005401221', '0.001786495', '0.000706175', '0.000411517', '0.033255728', '0.004816742', '0.002514485', '0.00212596', '0.000565159', '0.000884961', '0.000764402', '0.000389598', '0.000430498', '0.00034154', '0.000337254', '0.000229885', '0.000262518', '0.000180992', '6.78E-05', '9.66E-05', '0.000734307', '0.000662952', '0.010558539', '0.127150277', '0.033781282', '0.005555768', '0.002557256', '0.001265107', '0.000792767', '0.000587152', '0.000471567', '0.006829036', '0.007625075', '0.002240884', '0.000979995', '0.000599856', '0.000485205', '0.001950768', '0.001323628', '0.002752267', '0.000807995', '0.001288772', '0.000832992', '0.000756126', '0.002440587', '0.001223316', '0.004421209', '0.020618033', '0.002049712', '0.00651141', '0.001530351', '0.001017583', '0.000708878', '0.000910173', '0.000796232', '0.000263267', '0.000263368', '0.001167957', '0.000592768', '0.000326842', '0.053299496', '0.003626071', '0.001043528']


    a = open('predicted_training_load.txt', 'r')
    b = []
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #     c = lines.strip()
        d = lines.split()
        b.append(d)
    a.close()
    # print(b)
    # print(len(b))
    final_list = []
    hold_original_predicted = []
    for elements in b:
        if len(elements) > 0:
            final_list.append(elements[0])
            hold_original_predicted.append(elements[0])
        else:
            final_list.append(0)
            hold_original_predicted.append(0)
    #     print('This is a trace point')
    #     print(final_list)
    next_final = []
    for elements in final_list:
        next_final.append(float(elements))

    a = open('load_predictor.txt', 'r')
    b = []
    for lines in a:
        #c = we strip the lines with c, making every line an item
    #     c = lines.strip()
        d = lines.split()
        b.append(d)
    a.close()
    # print(b)
    # print(len(b))
    final_list = []
    for elements in b:
        if len(elements) > 0:
            final_list.append(elements[0])
        else:
            final_list.append(0)
#     print('This is a trace point')
#     print(final_list)
    next_final = []
    for elements in final_list:
        next_final.append(float(elements))
    
#     print(next_final) final_list was the list predicted from the code above.

        # print(f"Predicted A for B = {new_B}: {predicted_A[0]}")
    print('\n')
        
    
    print('\n')
    print('''##########################################################################################################################################################
##########################################################################################################################################################
##########################################################################################################################################################
##########################################################################################################################################################
##########################################################################################################################################################
    ''')
    print('\n\n')
    print('Using the equation to find the concentration in hope that the sine and cosine effect is wiped out')
    print('\n')
    coef_log = []
    a = open('coefficients.txt', 'r')
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #         c = lines.strip()
        d = lines.split()
        coef_log.append(float(d[0]))
    a.close()
    print('These are the coefficients')
    print(coef_log)
    print('\n')
    for elements in range (0, len(coef_log)):
        if elements == 0:
            baseb1 = coef_log[elements]
        elif elements == 1:
            baseb2 = coef_log[elements]
        elif elements == 2:
            baseb3 = coef_log[elements]
        elif elements == 3:
            baseb0 = coef_log[elements]
        elif elements == 4:
            eveb1 = coef_log[elements]
        elif elements == 5:
            eveb2 = coef_log[elements]
        elif elements == 6:
            eveb3 = coef_log[elements]
        else:
            eveb0 = coef_log[elements]
    predict1 = []    
    a = open('predicted_training_flow_time_load.txt', 'r')
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #         c = lines.strip()
        d = lines.split()
        predict1.append(d)
    a.close()

#     print('This is for you emeka')
#     print('\n')
#     print('Hinge point Emeka')
#     print(predict1)
#     print(len(predict1))
    flow = []
    time = []
    load = []
    for elements in range (0, len(predict1)):
        flow.append(float(predict1[elements][0]))
        time.append(float(predict1[elements][1]))
        load.append(float(predict1[elements][2]))
#     print('This is the flow')
#     print(flow)
#     print('\n')
    print('This is the flow')
    for elements in flow:
        print(elements)
    print('\n')
#     print('This is the time')
#     print(time)
#     print('\n')
#     print('This is the load')
#     print(load)
#     print('\n')
#     rad1 = 57.2958

    pure_load = []
    a = open('original_load.txt', 'r')
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #         c = lines.strip()
        d = lines.split()
        pure_load.append(float(d[0]))
    a.close()
#     print('These are the original load')
#     print(pure_load)
#     print('\n')

    original_concentration = []
    for elements in range (0, len(pure_load)):
        concen = (pure_load[elements]/flow[elements]) * 10
        original_concentration.append(concen)
    print('This is Original Concentration')
    print(original_concentration)
    
    pi = 3.14159265358979323846264338327950288419716939937510
    degree_list = []
    natural_log_load = []
    for elements in range (0, len(time)):
        change = time[elements] * 2 * pi
        if change <= 0:
            change = 0.0027359832 * 2 * pi
        degree_list.append(change)
        load_log = math.log(load[elements])
        natural_log_load.append(load_log)
#     print('This is your load log')
#     print(natural_log_load)
#     print(degree_list)
#     print(len(degree_list))
#     Y = np.array(flow, dtype=float)
#     Q = np.array(time, dtype=float)
#     t = np.array(load, dtype=float)
#     print('This is the special time')
#     print(t)
    sine_list = []
    cos_list = []
    for elements in range (0, len(degree_list)):
        sine = math.sin(degree_list[elements])
        sine_list.append(sine)
        cosine = math.cos(degree_list[elements])
        cos_list.append(cosine)
    
    e = 2.71828
    total_conc = []
    distortion = []
    a = open('distortion_point.txt', 'r')
    for lines in a:
        d = lines.split()
        distortion.append(float(d[0]))
    a.close()
    event_start = distortion[0]
    bump = eveb1/baseb1
    for elements in range (0, len(load)):
        power = (natural_log_load[elements] - (baseb2 * sine_list[elements]) - (baseb3 * cos_list[elements]) - (baseb0))/baseb1
        denom = e**power
        concc = (load[elements]/denom)*10
        total_conc.append(concc)
        
    conc_special_dif_sum = 0
    occurance = 0
    for elements in range (0, len(total_conc)):
        if load[elements] > event_start:
            conc_special_dif_sum += (original_concentration[elements] / total_conc[elements])
            occurance += 1
    # print(conc_special_dif_sum)
    # print(occurance)
    print('\n')
    
    down_call = False
    
    if occurance > 0:
        factor = conc_special_dif_sum/occurance
        down_call = True
        print(f'The factor is {factor}')
    #     print(factor)
    print('\n')
    print(f'The event start is {event_start}')
    print('\n')
    for elements in range (0, len(total_conc)):
        if load[elements] > event_start:
            high_conc = total_conc[elements] * factor
            total_conc[elements] = high_conc
            
            
    #         concc = (2 * 4.5 * (load[elements]/denom))*10
    # #         total_conc[elements] = factor * total_conc[elements]
    #         total_conc[elements] = concc

    print(f'This is of length of the list {len(total_conc)}')
    print('\n')
    print(f'This is the maximum value in the list {max(total_conc)}')
    print('\n')
    print(f'This is the minimum value in the list {min(total_conc)}')
    print('\n')
#     print('This is the final predicted equation concentration')
#     for elements in total_conc:
#         print(elements)

    ## This code is designed to catch event flow in inorganic
    date_type = 'd' ## I left the hourly event here incase I might need it for a finer data analysis
    Discharge = flow
    Dates = flow
    
    event_point_out = float(input('What is the value of the event start point: '))
    def Event(Discharge, Dates, event_point_out):
        if date_type == 'd':            
            percentage_discharge_change = ['event']
            for elements in range(1, len(Discharge)):
                y = Discharge[elements]
                change = y - Discharge[elements - 1]
                if Discharge[elements - 1 ] == 0:
                    percentage_discharge_change.append('no flow')
                else:
                    percent_change = (change/Discharge[elements - 1]) * 100
                    percentage_discharge_change.append(percent_change)
                
            
            for elements in range(0, len(percentage_discharge_change)):
                c = f'{elements + 1} - {percentage_discharge_change[elements]}'
        #         print(c)
            high_compound_flow = []
            low_compound_flow = []
            combine_compound_flow = []
            events = []
            event_dates = []
            baseflow = []
            baseflow_dates = []
            event_endpoint = 0
            event_bunch = []
            catch_no = 0
            packer = 0
            caught_events = {}
            event_occuring = False
            switch = False        
            event_point = event_point_out
            if Discharge[0] > event_point:          
                event_occuring = True
                ## this part supplies the whole data for the analysis
            event_ends = 0
            base_compound = 0
            high_compound = 0
            for elements in range(0, len(Discharge)):
        #         event_ends = 0
        #         base_compound = 0
        #         high_compound = 0
                last_slope = -1
                if event_occuring and elements >= len(events):
                    truncated_list = Discharge[elements:]
                    section_dates = Dates[elements:]
                    changing_flow = percentage_discharge_change[elements:]
                    ## this part sections the whole data at event point and works on it until the event ends
                    for elements1 in range(0, len(truncated_list)):
        #                 the part logs the event
                        if event_occuring:
                            if truncated_list[elements1] > event_point:
                                event_ends = 0
                                if elements1 > 0:
                                    if changing_flow[elements1] == 'no flow':
                                        changing_flow[elements1] = 0.0000000001
                                    if changing_flow[elements1] < 0:
                                        events.append(truncated_list[elements1])
                                        event_dates.append(section_dates[elements1])
                                        last_slope = changing_flow[elements1]
                                        baseflow.append('')
                                    else:
                                        if last_slope < 0:
                                            high_compound += 1
                                            events.append(truncated_list[elements1])
                                            event_dates.append(section_dates[elements1])
                                            last_slope = changing_flow[elements1]
                                            baseflow.append('')
                                        else:
                                            events.append(truncated_list[elements1])
                                            event_dates.append(section_dates[elements1])
                                            last_slope = changing_flow[elements1]
                                            baseflow.append('')
                                else:
                                    event_ends = 0
                                    events.append(truncated_list[elements1])
                                    event_dates.append(section_dates[elements1])
                                    baseflow.append('')
        #                         the part chech if the event is ended and if base flow as begun
                            else:                        
                                event_ends += 1
                                if event_ends < 2:
                                    events.append(truncated_list[elements1])
                                    event_dates.append(section_dates[elements1])
                                    drop_1 = truncated_list[elements1]
                                    baseflow.append('')
                                #this part checks if a compount event begins after reaching baseflow treshold
                                else:
                                    if truncated_list[elements1] <= drop_1:
                                        baseflow.append(truncated_list[elements1])
                                        baseflow_dates.append(section_dates[elements1])
                                        event_occuring = False
                                        switch = True
                                        event_endpoint = elements1
                                        events.append('')
                                    else:
        #                             This part check if it is a slight bump, is significant to creat compound event
                                        if truncated_list[elements1] <= event_point:
                                            baseflow.append(truncated_list[elements1])
                                            baseflow_dates.append(section_dates[elements1])
                                            events.append('')
                                            event_occuring = False
                                            switch = True
                                            event_endpoint = elements1
                                        else:
                                            base_compound += 1
                                            events.append(truncated_list[elements1])
                                            event_dates.append(section_dates[elements1])
                                            baseflow.append('')
                else:
                    if len(events) > 0 and len(events) >= packer and switch == True:
                        catch_no += 1
                        event_bunch.append(events)
                        packer = len(events)
                        caught_events[f'{catch_no} event '] = f'{event_dates[0]} - {event_dates[-1]}'
                        switch = False
                        if high_compound > 1:
                            if base_compound > 1:
                                combine_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                            else:
                                high_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                        elif base_compound > 1:
                            low_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                            
                    if elements >= len(events):
                        if Discharge[elements] >= event_point:
                            event_ends = 0
                            event_dates = []
                            event_occuring = True
                            if event_occuring and elements >= len(events):
                                truncated_list = Discharge[elements:]
                                section_dates = Dates[elements:]
                                changing_flow = percentage_discharge_change[elements:]
                                ## this part sections the whole data at event point and works on it until the event ends
                                for elements1 in range(0, len(truncated_list)):
                    #                 the part logs the event
                                    if event_occuring:
                                        if truncated_list[elements1] > event_point:
                                            event_ends = 0
                                            if elements1 > 0:
                                                if changing_flow[elements1] == 'no flow':
                                                    changing_flow[elements1] = 0.0000000001
                                                if changing_flow[elements1] < 0:
                                                    events.append(truncated_list[elements1])
                                                    event_dates.append(section_dates[elements1])
                                                    last_slope = changing_flow[elements1]
                                                    baseflow.append('')
                                                else:
                                                    if last_slope < 0:
                                                        high_compound += 1
                                                        events.append(truncated_list[elements1])
                                                        event_dates.append(section_dates[elements1])
                                                        last_slope = changing_flow[elements1]
                                                        baseflow.append('')
                                                    else:
                                                        events.append(truncated_list[elements1])
                                                        event_dates.append(section_dates[elements1])
                                                        last_slope = changing_flow[elements1]
                                                        baseflow.append('')
                                            else:
                                                event_ends = 0
                                                events.append(truncated_list[elements1])
                                                event_dates.append(section_dates[elements1])
                                                baseflow.append('')
                    #                         the part chech if the event is ended and if base flow as begun
                                        else:                        
                                            event_ends += 1
                                            if event_ends < 2:
                                                events.append(truncated_list[elements1])
                                                event_dates.append(section_dates[elements1])
                                                drop_1 = truncated_list[elements1]
                                                baseflow.append('')
                                            #this part checks if a compount event begins after reaching baseflow treshold
                                            else:
                                                if truncated_list[elements1] <= drop_1:
                                                    baseflow.append(truncated_list[elements1])
                                                    baseflow_dates.append(section_dates[elements1])
                                                    event_occuring = False
                                                    switch = True
                                                    event_endpoint = elements1
                                                    events.append('')
                                                else:
                    #                             This part check if it is a slight bump, is significant to creat compound event
                                                    if truncated_list[elements1] <= event_point:
                                                        baseflow.append(truncated_list[elements1])
                                                        baseflow_dates.append(section_dates[elements1])
                                                        events.append('')
                                                        event_occuring = False
                                                        switch = True
                                                        event_endpoint = elements1
                                                    else:
                                                        base_compound += 1
                                                        events.append(truncated_list[elements1])
                                                        event_dates.append(section_dates[elements1])
                                                        baseflow.append('')
                            else:
                                if len(events) > 0 and len(events) >= packer and switch == True:
                                    catch_no += 1
                                    event_bunch.append(events)
                                    packer = len(events)
                                    caught_events[f'{catch_no} event '] = f'{event_dates[0]} - {event_dates[-1]}'
                                    switch = False
                                    if high_compound > 1:
                                        if base_compound > 1:
                                            combine_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                                        else:
                                            high_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                                    elif base_compound > 1:
                                        low_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                 
                        else:
                            baseflow.append(Discharge[elements])
                            baseflow_dates.append(Dates[elements])
                            events.append('')                        
            
    #         print(f'''Caught_event -
    #         {caught_events}''')
    #         print(len(caught_events))
    #         print('\n')
    #         print(f'Number of events - {len(caught_events)}')
    #         print('\n')
    #         print('\n')
#             print('EVENTS')
#             for elements in events:
#                 print(elements)
#             print('end')
            return events
#             print('\n')
            
            
        elif date_type == 'h':
            a = open('hourly_event_data.txt', 'r')
            a1 = open('Hourly_Dates.txt', 'r')
            b = []
            b1 = []
            for lines in a:
                #c = we strip the lines with c, making every line an item
                c = lines.strip()
                d = lines.split()
                b.append(d)
            a.close()
            
            for lines in a1:
                #c = we strip the lines with c, making every line an item
                c = lines.strip()
                d = lines.split()
                b1.append(d)
            a1.close()
            
        #     
            Discharge = []
            Dates = []
            for elements in b1:
                Dates.append((elements))
                
            print('\n')  

            percentage_discharge_change = ['event']
            for elements in range(1, len(Discharge)):
                y = Discharge[elements]
                change = y - Discharge[elements - 1]
                if Discharge[elements - 1 ] == 0:
                    percentage_discharge_change.append('no flow')
                else:
                    percent_change = (change/Discharge[elements - 1]) * 100
                    percentage_discharge_change.append(percent_change)
                
            
            for elements in range(0, len(percentage_discharge_change)):
                c = f'{elements + 1} - {percentage_discharge_change[elements]}'
        #         print(c)
            high_compound_flow = []
            low_compound_flow = []
            combine_compound_flow = []
            events = []
            event_dates = []
            baseflow = []
            baseflow_dates = []
            event_endpoint = 0
            event_bunch = []
            catch_no = 0
            packer = 0
            caught_events = {}
            event_occuring = False
            switch = False
            event_point = event_point_out
            if Discharge[0] > event_point:        
                event_occuring = True
                ## this part supplies the whole data for the analysis
            event_ends = 0
            base_compound = 0
            high_compound = 0
            for elements in range(0, len(Discharge)):
        #         event_ends = 0
        #         base_compound = 0
        #         high_compound = 0
                last_slope = -1
                if event_occuring and elements >= len(events):
                    truncated_list = Discharge[elements:]
                    section_dates = Dates[elements:]
                    changing_flow = percentage_discharge_change[elements:]
                    ## this part sections the whole data at event point and works on it until the event ends
                    for elements1 in range(0, len(truncated_list)):
        #                 the part logs the event
                        if event_occuring:
                            if truncated_list[elements1] > event_point:
                                event_ends = 0
                                if elements1 > 0:
                                    if changing_flow[elements1] == 'no flow':
                                        changing_flow[elements1] = 0.0000000001
                                    if changing_flow[elements1] < 0:
                                        events.append(truncated_list[elements1])
                                        event_dates.append(section_dates[elements1])
                                        last_slope = changing_flow[elements1]
                                        baseflow.append('')
                                    else:
                                        if last_slope < 0:
                                            high_compound += 1
                                            events.append(truncated_list[elements1])
                                            event_dates.append(section_dates[elements1])
                                            last_slope = changing_flow[elements1]
                                            baseflow.append('')
                                        else:
                                            events.append(truncated_list[elements1])
                                            event_dates.append(section_dates[elements1])
                                            last_slope = changing_flow[elements1]
                                            baseflow.append('')
                                else:
                                    event_ends = 0
                                    events.append(truncated_list[elements1])
                                    event_dates.append(section_dates[elements1])
                                    baseflow.append('')
        #                         the part chech if the event is ended and if base flow as begun
                            else:                        
                                event_ends += 1
                                if event_ends < 2:
                                    events.append(truncated_list[elements1])
                                    event_dates.append(section_dates[elements1])
                                    drop_1 = truncated_list[elements1]
                                    baseflow.append('')
                                #this part checks if a compount event begins after reaching baseflow treshold
                                else:
                                    if truncated_list[elements1] <= drop_1:
                                        baseflow.append(truncated_list[elements1])
                                        baseflow_dates.append(section_dates[elements1])
                                        event_occuring = False
                                        switch = True
                                        event_endpoint = elements1
                                        events.append('')
                                    else:
        #                             This part check if it is a slight bump, is significant to creat compound event
                                        if truncated_list[elements1] <= event_point:
                                            baseflow.append(truncated_list[elements1])
                                            baseflow_dates.append(section_dates[elements1])
                                            events.append('')
                                            event_occuring = False
                                            switch = True
                                            event_endpoint = elements1
                                        else:
                                            base_compound += 1
                                            events.append(truncated_list[elements1])
                                            event_dates.append(section_dates[elements1])
                                            baseflow.append('')
                else:
                    if len(events) > 0 and len(events) >= packer and switch == True:
                        catch_no += 1
                        event_bunch.append(events)
                        packer = len(events)
                        caught_events[f'{catch_no} event '] = f'{event_dates[0]} - {event_dates[-1]}'
                        switch = False
                        if high_compound > 1:
                            if base_compound > 1:
                                combine_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                            else:
                                high_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                        elif base_compound > 1:
                            low_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                            
                    if elements >= len(events):
                        if Discharge[elements] >= event_point:
                            event_ends = 0
                            event_dates = []
                            event_occuring = True
                            if event_occuring and elements >= len(events):
                                truncated_list = Discharge[elements:]
                                section_dates = Dates[elements:]
                                changing_flow = percentage_discharge_change[elements:]
                                ## this part sections the whole data at event point and works on it until the event ends
                                for elements1 in range(0, len(truncated_list)):
                    #                 the part logs the event
                                    if event_occuring:
                                        if truncated_list[elements1] > event_point:
                                            event_ends = 0
                                            if elements1 > 0:
                                                if changing_flow[elements1] == 'no flow':
                                                    changing_flow[elements1] = 0.0000000001
                                                if changing_flow[elements1] < 0:
                                                    events.append(truncated_list[elements1])
                                                    event_dates.append(section_dates[elements1])
                                                    last_slope = changing_flow[elements1]
                                                    baseflow.append('')
                                                else:
                                                    if last_slope < 0:
                                                        high_compound += 1
                                                        events.append(truncated_list[elements1])
                                                        event_dates.append(section_dates[elements1])
                                                        last_slope = changing_flow[elements1]
                                                        baseflow.append('')
                                                    else:
                                                        events.append(truncated_list[elements1])
                                                        event_dates.append(section_dates[elements1])
                                                        last_slope = changing_flow[elements1]
                                                        baseflow.append('')
                                            else:
                                                event_ends = 0
                                                events.append(truncated_list[elements1])
                                                event_dates.append(section_dates[elements1])
                                                baseflow.append('')
                    #                         the part chech if the event is ended and if base flow as begun
                                        else:                        
                                            event_ends += 1
                                            if event_ends < 2:
                                                events.append(truncated_list[elements1])
                                                event_dates.append(section_dates[elements1])
                                                drop_1 = truncated_list[elements1]
                                                baseflow.append('')
                                            #this part checks if a compount event begins after reaching baseflow treshold
                                            else:
                                                if truncated_list[elements1] <= drop_1:
                                                    baseflow.append(truncated_list[elements1])
                                                    baseflow_dates.append(section_dates[elements1])
                                                    event_occuring = False
                                                    switch = True
                                                    event_endpoint = elements1
                                                    events.append('')
                                                else:
                    #                             This part check if it is a slight bump, is significant to creat compound event
                                                    if truncated_list[elements1] <= event_point:
                                                        baseflow.append(truncated_list[elements1])
                                                        baseflow_dates.append(section_dates[elements1])
                                                        events.append('')
                                                        event_occuring = False
                                                        switch = True
                                                        event_endpoint = elements1
                                                    else:
                                                        base_compound += 1
                                                        events.append(truncated_list[elements1])
                                                        event_dates.append(section_dates[elements1])
                                                        baseflow.append('')
                            else:
                                if len(events) > 0 and len(events) >= packer and switch == True:
                                    catch_no += 1
                                    event_bunch.append(events)
                                    packer = len(events)
                                    caught_events[f'{catch_no} event '] = f'{event_dates[0]} - {event_dates[-1]}'
                                    switch = False
                                    if high_compound > 1:
                                        if base_compound > 1:
                                            combine_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                                        else:
                                            high_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                                    elif base_compound > 1:
                                        low_compound_flow.append(f'{event_dates[0]} - {event_dates[-1]}')
                 
                        else:
                            baseflow.append(Discharge[elements])
                            baseflow_dates.append(Dates[elements])
                            events.append('')                        
            
    #         print(f'''event_dates -
    #         {event_dates}''')
    #         print(len(event_dates))
    #         print('\n')
    #         print(f'''Caught_event -
    #         {caught_events}''')
    #         print(len(caught_events))
    #         print('\n')
    #         print(f'Number of events - {len(caught_events)}')
    #         print('\n')

            batch_no = input('''The data span in hourly is so large we have to print in batches of 8000 lines

        what batch would you like to print?
            for first batch press - 1
            for second batch press - 2
            for third batch press - 3
            etc
            
            ''')
    #         print('\n')
    #         print('Events')
            try:
                batch_no = int(batch_no)
                xx = batch_no - 1
                Range = 8000
                start = xx * Range
#                 for elements in range(0, len(events)):
#                     if elements >= start and elements <= start + Range - 1:
#                         print(events[elements])
#                 print('End')
                return events
                
            except:
                print('ERROR')
                print('Batch Number must be integer')
                exit()
    events = Event(Discharge, Dates, event_point_out)
        
    total_second_bump = 0
    occurance = 0
    for elements in range (0, len(events)):
    #     print(type(events[elements]))
        if type(events[elements]) == float:
            gap = original_concentration[elements] / total_conc[elements]
            total_second_bump += gap
            occurance += 1
    # print(total_second_bump)
    # print(occurance)
    if occurance > 0:
        need_pump = total_second_bump/occurance
        print(need_pump)
        print('\n')

    if need_pump > 1.049:
        for elements in range (0, len(events)):
        #     print(type(events[elements]))
            if type(events[elements]) == float:
                y = total_conc[elements] * need_pump
                total_conc[elements] = y
    else:
        print('poor event quality')
        print('\n')
    
    print('This is the final concentration prediction')
    for elements in total_conc:
        print(elements)
    
    print('\n')
    print('First round pred coefficient')
    print(f'baseb1 = {baseb1}')
    print(f'baseb2 = {baseb2}')
    print(f'baseb3 = {baseb3}')
    print(f'baseb0 = {baseb0}')
    print(f'eveb1 = {eveb1}')
    print(f'eveb2 = {eveb2}')
    print(f'eveb3 = {eveb3}')
    print(f'eveb0 = {eveb0}')
    
    if down_call == True:
        print(f'Case1 bump: {factor}')
    print(f'Case2 bump: {need_pump}')
    print('\n')
    print('This is the testing or validationg data')
    
    predict1 = []
    predict2 = []

    a = open('original_smaller_set_load.txt', 'r')
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #         c = lines.strip()
        d = lines.split()
        predict1.append(d)
    a.close()
    
    a = open('new_small_pred_load_time.txt', 'r')
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #         c = lines.strip()
        d = lines.split()
        predict2.append(d)
    a.close()

#     print('This is for you emeka')
#     print('\n')
#     print('Hinge point Emeka')
#     print(predict1)
#     print(len(predict1))
    load = []
    time = []
    flow = []
    for elements in range (0, len(predict1)):
        load.append(float(predict1[elements][0]))
        time.append(float(predict2[elements][1]))
        flow.append(float(predict2[elements][2]))
#     print('\n')
#     print(load)
#     print(time)
#     print(flow)
    
    Discharge = flow
    Dates = time
    events = Event(Discharge, Dates, event_point_out)
    print('\n')
#     print('Smaller event')
#     print(events)
    
    total_conc = []
    original_concentration = []
    for elements in range (0, len(load)):
        concen = (load[elements]/flow[elements]) * 10
        original_concentration.append(concen)
    print('This is Original small set Concentration')
    print(original_concentration)
    print(len(original_concentration))
    
    predict1 = []
    a = open('new_small_pred_load_time.txt', 'r')
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #         c = lines.strip()
        d = lines.split()
        predict1.append(d)
    a.close()
    
    load = []
    for elements in range (0, len(predict1)):
        load.append(float(predict1[elements][0]))
        
    pi = 3.14159265358979323846264338327950288419716939937510
    degree_list = []
    natural_log_load = []
    for elements in range (0, len(time)):
        change = time[elements] * 2 * pi
        if change <= 0:
            change = 0.0027359832 * 2 * pi
        degree_list.append(change)
        load_log = math.log(load[elements])
        natural_log_load.append(load_log)
    
    sine_list = []
    cos_list = []
    for elements in range (0, len(degree_list)):
        sine = math.sin(degree_list[elements])
        sine_list.append(sine)
        cosine = math.cos(degree_list[elements])
        cos_list.append(cosine)
    
    
    for elements in range (0, len(load)):
        power = (natural_log_load[elements] - (baseb2 * sine_list[elements]) - (baseb3 * cos_list[elements]) - (baseb0))/baseb1
        denom = e**power
        concc = (load[elements]/denom)*10
        total_conc.append(concc)
        
    for elements in range (0, len(total_conc)):
        if load[elements] > event_start:
            high_conc = total_conc[elements] * factor
            total_conc[elements] = high_conc
    
    total_second_bump = 0
    occurance = 0
    for elements in range (0, len(events)):
    #     print(type(events[elements]))
        if type(events[elements]) == float:
            gap = original_concentration[elements] / total_conc[elements]
            total_second_bump += gap
            occurance += 1
    # print(total_second_bump)
    # print(occurance)
#     if occurance > 0:
    need_pump = total_second_bump/occurance
    print(f'concentration jump facctor {need_pump}')
    print('\n')

    if need_pump > 1.049:
        for elements in range (0, len(events)):
        #     print(type(events[elements]))
            if type(events[elements]) == float:
                y = total_conc[elements] * need_pump
                total_conc[elements] = y
    else:
        print('poor event quality')
        print('\n')
    
    print('This is the final small set concentration prediction')
    for elements in total_conc:
        print(elements)
        
    
#     print('\n')
#     print('This is the NSE Value for the Calibration Model')
#     print('This is the original full load')
#     print(pure_load)
#     print(len(pure_load))
#     print('\n')
#     print('This could be the full predicted load')
#     print(hold_original_predicted)
#     print(len(hold_original_predicted))
#     print('\n')
#     print('This is the minor predicted load')
#     print(load)
#     print(len(load))
    original_small_set_load = []
    a = open('original_smaller_set_load.txt', 'r')
    for lines in a:
        # c = we strip the lines with c, making every line an item
        #         c = lines.strip()
        d = lines.split()
        original_small_set_load.append(float(d[0]))
    a.close()
#     print('\n')
#     print(original_small_set_load)
#     print(len(original_small_set_load))
    
    #     NSE Calculation for the training data set
    
    mean_original_cali = sum(pure_load)/len(pure_load)
    A = 0
    B = 0
    NSE = 0
    for elements in range(0, len(pure_load)):
        y = (float(hold_original_predicted[elements]) - float(pure_load[elements]))**2
        A += y
        x = (float(pure_load[elements]) - mean_original_cali)**2
        B += x
        NSE = 1 - (A/B)
    print('\n')
#     print(mean_original_cali)
#     print(A)
#     print(B)
#     print('\n')
    print('This is the NSE of the original Calibration data')
    print(NSE)
    
    print('\n')
    mean_original_cali = sum(original_small_set_load)/len(original_small_set_load)
    A = 0
    B = 0
    NSE = 0
    for elements in range(0, len(original_small_set_load)):
        y = (float(load[elements]) - float(original_small_set_load[elements]))**2
        A += y
        x = (float(original_small_set_load[elements]) - mean_original_cali)**2
        B += x
        NSE = 1 - (A/B)
#     print('\n')
#     print(mean_original_cali)
#     print(A)
#     print(B)
#     print('\n')
    print('This is the NSE of the smaller validation data')
    print(NSE)
    
    # Data
    print('\n')
    x = []
    for elements in pure_load:
        x.append(float(elements))
#     x = pure_load # Reshape for sklearn

    y = []
    for elements in hold_original_predicted:
        y.append(float(elements))
#     print(x)
#     print(y)
    correlation, _ = pearsonr(x, y)
    print(f"Correlation coefficient: {correlation}")
    print('\n')
    print('The standard deviation for the observed cali')
    std_dev1 = np.std(x, ddof=0)
    print('\n')
    std_dev1 = statistics.stdev(x)
    print(f"Standard Deviation: {std_dev1:.4f}")
    print('The standard deviation for the simulated cali')
    std_dev = np.std(y, ddof=0)
    print('\n')
    std_dev = statistics.stdev(y)
    print(f"Standard Deviation: {std_dev:.4f}")
    print('\n')
    mean1 = sum(y)/len(y)
    print('mean predicted cali')
    print(mean1)
    print('\n')
    mean = sum(x)/len(x)
    print('mean observed cali')
    print(mean)
    
    print('''
#######################################################################################################################################################################
   ''')
    
    KGE = 1 - (((correlation-1)**2)+(((std_dev/std_dev1)-1)**2)+(((mean1/mean)-1)**2))**0.5
    print('This is your KGE for calibration')
    print(KGE)
    
   # Data
#     print('\n')
    print('\n')
    x = []
    for elements in original_small_set_load:
        x.append(float(elements))
#     x = pure_load # Reshape for sklearn

    y = []
    for elements in load:
        y.append(float(elements))
    
    correlation, _ = pearsonr(x, y)
    print(f"Correlation coefficient: {correlation}")
    print('\n')
    print('The standard deviation for the observed vali')
    std_dev1 = np.std(x, ddof=0)
    print('\n')
    std_dev1 = statistics.stdev(x)
    print(f"Standard Deviation: {std_dev1:.4f}")
    print('\n')
    print('The standard deviation for the simulated vali')
    std_dev = np.std(y, ddof=0)
    print('\n')
    std_dev = statistics.stdev(y)
    print(f"Standard Deviation: {std_dev:.4f}")
    print('\n')
    mean1 = sum(y)/len(y)
    print('mean predicted vali')
    print(mean1)
    print('\n')
    mean = sum(x)/len(x)
    print('mean observed vali')
    print(mean)
    print('\n')
    
    KGE = 1 - (((correlation-1)**2)+(((std_dev/std_dev1)-1)**2)+(((mean1/mean)-1)**2))**0.5
    print('This is your KGE for validation')
    print(KGE)
    print('\n')
    
###################################################################################################################################################################################################################################
###################################################################################################################################################################################################################################
    
    a = open('original_load.txt', 'r')
    b = []
    for lines in a:
        #c = we strip the lines with c, making every line an item
    #     c = lines.strip()
        d = lines.split()
        b.append(d)
    a.close()
    # print(b)
    # print(len(b))
    final_list = []
    for elements in b:
        if len(elements) > 0:
            final_list.append(elements[0])
        else:
            final_list.append(0)
    # print(final_list)
    # print(len(final_list))
    data = final_list

    ###############################################################################################################################
    a = open('original_smaller_set_load.txt', 'r')
    b = []
    for lines in a:
        #c = we strip the lines with c, making every line an item
    #     c = lines.strip()
        d = lines.split()
        b.append(d)
    a.close()
    # print(b)
    # print(len(b))
    final_list = []
    for elements in b:
        if len(elements) > 0:
            final_list.append(elements[0])
        else:
            final_list.append(0)
    # print(final_list)
    # print(len(final_list))

    data0 = final_list
    ## This Kolmogorov-Smirnov test is used to test the different between two distribution

    # Example datasets (uneven sizes)
    # np.random.seed(42)
    # data1 = np.random.normal(loc=50, scale=10, size=800)   # Dataset 1 (e.g., Training)
    # data2 = np.random.normal(loc=20, scale=10, size=1200)  # Dataset 2 (e.g., Validation)


    ##  This should be the training data set
    # data = ['0.003849735', '0.001007946', '0.000631602', '6.89E-05', '5.26E-05', '3.64E-05', '3.67E-05', '1.60E-05', '1.11E-05', '7.67E-06', '7.12E-06', '6.22E-06', '2.72E-05', '2.50E-05', '3.28E-05', '2.59E-05', '3.32E-05', '1.66E-05', '2.26E-06', '1.52E-05', '0.000454131', '0.000650931', '4.08E-05', '2.85E-05', '0.008343204', '0.003211949', '0.000765691', '0.000132216', '0.000325159', '8.15E-05', '3.71E-05', '2.36E-05', '1.72E-05', '9.44E-06', '6.21E-06', '4.18E-05', '0.002742866', '0.000745716', '0.000273', '0.000255', '0.000756', '0.000172', '0.000114531', '6.78E-05', '5.07E-05', '0.000126', '4.39E-05', '9.92E-05', '0.000104', '8.30E-05', '8.61E-05', '8.63E-05', '4.50E-05', '0.005281626', '0.00102', '0.000103', '0.000162', '4.96E-05', '3.77E-05', '3.47E-05', '6.50E-05', '2.41E-05', '0.00152', '0.00675', '0.000733', '0.008059681', '5.09E-05', '5.08E-05', '4.82E-05', '2.66E-05', '2.13E-05', '2.07E-05', '1.97E-05', '2.01E-05', '0.000351', '5.60E-05', '3.80E-05', '0.000356', '7.94E-05', '4.44E-05', '4.17E-05', '0.002258794', '4.17E-05', '2.82E-05', '9.90E-06', '2.14E-05', '1.71E-05', '5.25E-06', '3.92E-06', '3.41E-06', '1.69E-05', '1.39E-05', '0.000569465', '0.000932631', '0.00183852', '0.00118', '0.000326', '0.000119', '4.68E-05', '4.49E-06', '5.22E-06', '4.50E-06', '3.58E-06', '1.85E-06', '0.000876', '5.67E-07', '1.57E-06', '0.00010896', '6.98E-05', '5.19E-05', '3.44E-05', '3.73E-05', '2.74E-05', '2.46E-05', '8.47E-06', '4.21E-05', '8.93E-05', '9.43E-05', '4.84E-05', '3.36E-05', '1.31E-05', '9.26E-06', '1.90E-07', '0.00079', '0.000576825', '0.000541283', '0.004512976', '0.000739054', '0.000296248', '0.000208', '0.000164', '0.000133', '9.33E-05', '9.69E-05', '0.000100605', '7.02E-05', '7.79E-05', '5.60E-05', '4.64E-05', '5.46E-05', '5.22E-05', '5.93E-05', '5.49E-05', '2.80E-05', '1.92E-05', '1.58E-05', '0.001078389', '0.006445813', '0.000688', '0.000384', '0.000464315', '0.009820128', '0.000813543', '0.000183', '0.000150247', '0.000128296', '0.00014', '0.000114', '0.0001', '6.12E-05', '4.29E-05', '2.21E-05', '2.94E-05', '3.42E-05', '6.75E-05', '5.48E-05', '5.36E-05', '4.35E-05', '3.05E-05', '2.47E-05', '7.76E-05', '5.11E-05', '4.09E-05', '9.82E-05', '9.96E-05', '6.43E-05', '9.28E-05', '6.71E-05', '7.92E-05', '9.80E-05', '7.72E-05', '5.04E-05', '3.41E-05', '1.67E-05', '1.58E-05', '2.51E-05', '3.08E-05', '4.40E-05', '2.93E-05', '2.11E-05', '1.81E-05', '1.47E-05', '1.37E-05', '1.45E-05', '2.09E-05', '1.44E-05', '9.62E-06', '8.31E-06', '0.00607', '0.00058109', '0.000241368', '0.000187114', '0.000155814', '0.000133314', '9.27E-05', '8.94E-05', '4.15E-05', '0.013798822', '0.000688525', '0.000438583', '0.000304045', '0.000253834', '0.000649088', '0.000566243', '0.000271846', '0.000154948', '9.07E-05', '2.26E-05', '0.00106327', '0.001897207', '0.001105755', '0.001176786', '0.000789682', '0.000533782', '0.000404357', '0.000367431', '0.000416987', '0.000302959', '0.000231856', '0.000196804', '0.000150182', '0.000106881', '0.000110054', '0.000432313', '0.000631939', '0.000519732', '0.000284459', '0.00016225', '0.00013276', '0.000109911', '0.000145926', '0.000147053', '8.74E-05', '7.69E-05', '7.29E-05', '7.84E-05', '7.27E-05', '7.97E-05', '8.74E-05', '0.000111563', '0.000241687', '0.002428882', '0.000181563', '0.000138246', '0.000128241', '8.23E-05', '8.32E-05', '9.93E-05', '0.000114684', '5.49E-05', '5.80E-05', '7.97E-05', '7.06E-05', '6.95E-05', '0.000393943', '0.000769866', '7.15E-05', '5.05E-05', '4.18E-05', '3.66E-05', '3.27E-05', '2.95E-05', '2.74E-05', '0.002924956', '0.002618058', '6.58E-05', '4.12E-05', '3.19E-05', '2.68E-05', '2.55E-05', '2.84E-05', '0.001545911', '9.72E-05', '5.95E-05', '3.75E-05', '0.000169053', '0.000154086', '0.0001561', '8.15E-05', '8.96E-05', '8.83E-05', '0.000157017', '0.00014299', '0.00011857', '0.000128696', '1.16E-05', '1.21E-05', '4.07E-05', '9.39E-05', '7.51E-05', '6.51E-06', '7.42E-06', '1.85E-05', '2.77E-05', '2.86E-05', '2.49E-05', '1.74E-05', '1.88E-05', '1.56E-05', '1.41E-05', '6.15E-06', '0.00108104', '0.000815239', '0.002285704', '0.001609004', '0.000658944', '0.00014763', '0.00012183', '9.72E-05', '8.04E-05', '9.76E-05', '5.44E-05', '0.000192571', '4.35E-05', '6.20E-05', '0.000135022', '4.98E-05', '4.73E-05', '4.23E-07', '2.17E-06', '4.06E-06', '1.56E-06', '0.002281879', '0.00064611', '0.000559007', '0.000429015', '5.45E-05', '1.79E-05', '0.000141107', '7.80E-05', '9.38E-05', '8.39E-05', '6.94E-05', '0.000124593', '0.000647366', '0.000332005', '0.000343824', '0.000109306', '7.25E-05', '6.42E-05', '0.000105937', '0.000102237', '5.89E-05', '0.000103153', '1.99E-05', '1.25E-05', '1.06E-05', '4.95E-06', '6.19E-06', '4.27E-06', '7.05E-06', '8.50E-06', '7.75E-06', '1.05E-05', '2.33E-05', '2.31E-05', '5.82E-05', '0.00013583', '0.000252357', '0.001392094', '0.001186042', '0.000576985', '0.000319394', '3.03E-05', '2.36E-05', '4.20E-05', '3.42E-05', '3.40E-05', '1.25E-05', '1.01E-05', '1.42E-05', '1.83E-05', '1.37E-05', '7.52E-06', '0.000126335', '5.48E-05', '3.53E-05', '2.62E-05', '0.00010421', '0.000481431', '0.000173131', '6.10E-05', '6.73E-05', '7.71E-05', '7.06E-05', '5.92E-05', '4.68E-05', '4.02E-05', '2.64E-05', '2.97E-05', '0.000282031', '0.000132948', '0.000702481', '0.017555811', '0.000604747', '0.000185652', '0.000389991', '0.00030493', '0.001858893', '0.001835104', '0.000811475', '0.000543538', '0.000372125', '0.000232232', '0.000101193', '3.90E-05', '1.77E-05', '2.86E-06', '8.60E-07', '8.26E-05', '0.004840469', '0.00450964', '0.001373552', '0.000444907', '3.35E-05', '1.26E-05', '0.000669547', '0.005400274', '0.003538716', '0.001705715', '0.000499222', '0.00012834', '1.22E-05', '1.65E-06', '5.65E-06', '4.17E-06', '1.68E-06', '0.019433248', '0.002942572', '0.001814509', '0.001285778', '4.51E-05', '9.88E-05', '0.000136589', '0.003761696', '0.001176', '0.000597296', '0.000367358', '0.000987416', '0.001690738', '0.000870623', '0.000395093', '0.00023259', '9.50E-05', '0.009287932', '0.013534551', '0.000846391', '0.000465288', '0.000382676', '0.000321137', '0.000397478', '0.000301757', '0.001000191', '0.00349503', '0.000856018', '0.010677323', '0.005200453', '0.0005999', '0.0003982', '0.000271663', '0.000179609', '0.000131981', '0.000110722', '9.10E-05', '6.20E-05', '5.57E-05', '6.10E-05', '5.98E-05', '4.68E-05', '3.85E-05', '3.21E-05', '4.05E-05', '5.58E-05', '6.96E-05', '7.09E-05', '7.08E-05', '0.000669688', '0.000281233', '0.000214533', '0.000506527', '0.00098625', '0.000690103', '0.000475325', '0.000347651', '0.003913158', '0.001398845', '0.001011543', '0.00070758', '0.000492031', '0.001833306', '0.001461642', '0.001065978', '0.000601962', '0.000423806', '0.001544016', '0.000993138', '0.000658699', '0.000465402', '0.000382796', '0.000360262', '0.000368483', '0.001427377', '0.002672583', '0.001132252', '0.000834277', '0.000637123', '0.000503356', '0.000403409', '0.000309502', '0.000242435', '0.00017011', '0.000139096', '9.77E-05', '8.72E-05', '0.00010991', '5.81E-05', '4.61E-05', '3.99E-05', '2.74E-05', '1.09E-05', '7.83E-06', '7.81E-06', '9.36E-06', '1.02E-05', '3.93E-06', '2.98E-06', '2.95E-06', '2.14E-05', '1.12E-05', '6.70E-06', '9.83E-06', '1.19E-05', '1.04E-05', '1.18E-05', '8.80E-06', '6.28E-06', '0.012596625', '0.005060108', '0.001588569', '0.001188286', '0.009311455', '0.001613528', '0.001039241', '0.000660874', '0.000612034', '0.000537425', '0.000566629', '0.000454203', '0.000420754', '0.001473186', '0.000992169', '0.000691529', '0.000502014', '0.000411322', '0.000325706', '0.000235347', '0.000224481', '0.000192672', '0.000174156', '0.000890809', '0.001204304', '0.000810383', '0.000523562', '0.000348274', '0.000344096', '0.000331389', '0.000208409', '0.00025691', '0.000435877', '0.000377551', '0.000462523', '0.000431112', '0.000372377', '0.000309756', '0.000284769', '0.000202635', '0.000226427', '0.000153297', '0.000127147', '0.000150643', '0.000256882', '0.000166509', '9.03E-05', '0.000125406', '0.000178929', '0.000200995', '0.000216312', '6.44E-05', '7.68E-05', '9.04E-05', '0.000320356', '0.003418077', '0.002861756', '0.000137332', '0.000588514', '0.000171096', '0.000246172', '6.09E-05', '0.000906984', '0.001219117', '0.001657862', '0.00021431', '0.000496896', '0.000155177', '0.000126368', '2.56E-05', '0.000596056', '5.43E-05', '0.000146913', '0.000114279', '7.27E-05', '2.19E-05', '3.39E-05', '3.31E-05', '3.82E-05', '5.75E-05', '9.14E-05', '8.89E-05', '0.000273366', '0.000155651', '0.000430928', '6.14E-05', '6.69E-05', '0.000165368', '6.91E-05', '0.000123692', '0.000118983', '0.000106146', '9.63E-05', '5.16E-05', '5.57E-05', '4.70E-05', '3.33E-05', '2.70E-05', '2.96E-05', '2.71E-05', '9.20E-06', '1.79E-06', '1.23E-05', '0.000220866', '7.14E-05', '2.98E-05', '3.55E-05', '4.24E-05', '3.83E-05', '3.72E-05', '2.63E-05', '0.00066578', '0.00010613', '4.36E-05', '2.49E-05', '2.07E-05', '1.27E-05', '4.68E-05', '0.002951673', '0.001814372', '0.000409166', '0.000274451', '0.000169848', '0.000225398', '0.000237387', '0.000291554', '0.000230307', '0.000318294', '0.000271313', '0.000249456', '0.000194596', '0.000115166', '0.000100606', '0.007425797', '0.000831467', '0.000565886', '0.000409758', '0.000307056', '0.000244115', '0.000177614', '0.000107641', '0.000120316', '9.00E-05', '8.71E-05', '0.00337092', '0.011494069', '0.002730112', '0.001827521', '0.000728338', '0.005349221', '0.003391914', '0.001030964', '0.001054947', '0.00428241', '0.003189067', '0.001900663', '0.000692547', '0.000466009', '0.000844359', '0.000443966', '0.00085541', '0.000359252', '0.00028796', '0.000222304', '0.000183434', '0.000142068', '0.000184339', '0.000142927', '0.000139574', '0.000585646', '0.000416854', '0.000301133', '0.000196393', '0.000236058', '0.001236497', '0.000692398', '0.000440482', '0.00135302', '0.001175105', '0.000753308', '0.000418714', '0.000355446', '0.00026366', '2.97E-05', '2.07E-05', '0.000114747', '9.46E-05', '8.78E-05', '3.35E-05', '9.78E-06', '1.13E-05', '1.26E-05', '1.82E-07', '0.000147767', '0.000798769', '0.000497168', '0.00035179', '0.000105839', '9.15E-05', '7.27E-05', '4.54E-05', '3.00E-05', '1.09E-05', '1.26E-05', '1.05E-05', '0.006217841', '0.000413103', '3.49E-05', '5.24E-06', '0.000347534', '6.89E-05', '5.34E-05', '2.48E-05', '1.67E-05', '5.16E-06', '6.86E-07', '0.000264507', '0.000394549', '0.000705644', '0.000625174', '0.000311098', '0.00027686', '0.000234417', '0.000191915', '0.000164377', '0.000159661', '0.000178208', '9.81E-05', '4.93E-05', '5.82E-05', '5.85E-05', '8.63E-05', '1.24E-05', '1.34E-05', '1.41E-05', '1.90E-05', '0.000599706', '0.000196939', '0.000169374', '0.0001657', '0.000152849', '0.000481365', '0.00036889', '0.000153226', '0.000110537', '9.50E-05', '7.47E-05', '4.36E-05', '2.69E-05', '1.47E-05', '0.00598', '0.00578', '0.001217257', '0.003574446', '0.001392183', '0.000850007', '0.000543446', '0.000297', '9.03E-05', '2.71E-05', '3.26E-05', '4.62E-05', '0.001055731', '0.009284865', '0.005123826', '0.004751256', '0.004862944', '0.003029208', '0.003101642', '0.002492394', '0.001516993', '0.000474492', '0.000368682', '0.000284', '0.000248162', '0.000207775', '0.000151171', '8.58E-05', '8.53E-05', '5.30E-05', '4.79E-05', '3.56E-05', '3.37E-05', '2.09E-05', '7.57E-05', '9.49E-05', '8.40E-05', '5.18E-05', '8.50E-05', '0.000108577', '0.000100885', '0.000105909', '0.000115715', '5.97E-05', '2.98E-05', '0.000901565', '0.000159489', '0.000128015', '8.42E-05', '0.003975247', '0.002773535', '0.001144005', '0.000760659', '0.000356189', '4.46E-05', '4.80E-05', '3.29E-05', '2.90E-05', '2.88E-05', '3.66E-05', '2.43E-05', '2.60E-05', '2.28E-05', '0.000122548', '0.000159192', '0.000964103', '0.005013123', '0.006504868', '0.001457057', '0.001905068', '0.001253492', '0.00056034', '0.000378114', '0.000233664', '0.000131209', '0.00707', '0.001962412', '0.000363', '0.000199267', '0.000142', '5.44E-05', '0.000703', '0.000263', '0.000122', '7.77E-05', '1.98E-05', '5.71E-06', '3.91E-06', '4.78E-06', '0.000100673', '0.000714373', '0.001701787', '0.000476593', '0.000399333', '0.000236901', '0.000138786', '0.000142', '0.000141', '0.00163', '0.000257', '0.000931', '0.000469', '0.000469', '0.000323', '2.26E-05', '1.68E-05', '2.08E-05', '0.000202', '0.000365', '0.000232', '3.53E-05', '1.44E-05', '0.00316', '0.00103', '0.00154', '0.00011', '0.000112', '0.000377', '0.000296', '0.000224', '0.00116', '4.60E-05', '0.000132', '0.000229', '0.00017', '0.000167', '3.43E-05', '3.00E-05', '1.07E-05', '2.14E-05', '2.73E-05', '7.65E-06', '2.74E-05', '4.36E-05', '2.01E-05', '2.40E-05', '1.98E-05', '9.19E-05', '0.000146777', '8.55E-05', '1.42E-05', '0.000189', '0.000113', '0.000111', '2.11E-05', '1.41E-05', '6.97E-06', '6.98E-07', '0.000915648', '8.71E-05', '3.48E-05', '1.56E-05', '6.07E-06', '1.70E-05', '1.46E-06', '6.44E-06', '4.25E-07', '4.23E-07', '6.17E-07', '2.05E-07', '6.52E-05', '9.23E-07']



    data1 = []
    for elements in data:
        data1.append(float(elements))


    ## this is the testing data set
    # data0 = ['2.90E-05', '2.08E-05', '0.001222154', '0.000307295', '0.001170162', '0.000199455', '0.000122792', '0.000120419', '5.37E-05', '4.68E-06', '8.16E-05', '5.91E-05', '8.09E-05', '0.00473312', '7.49E-05', '9.70E-05', '3.52E-05', '0.000586964', '6.50E-05', '1.59E-05', '3.98E-05', '9.06E-05', '7.78E-07', '0.001787781', '0.00264', '0.000108059', '0.000104159', '9.19E-05', '0.006599863', '0.000426331', '0.000309', '0.000216', '7.72E-05', '8.18E-05', '4.00E-05', '3.60E-05', '0.000461525', '5.64E-05', '6.14E-05', '1.52E-05', '0.000685', '0.000114187', '6.11E-05', '1.04E-05', '0.009153876', '0.001676765', '0.000372009', '0.000197619', '0.000168855', '0.000127974', '0.000111233', '9.67E-05', '0.000105788', '5.73E-05', '9.99E-05', '4.99E-05', '3.57E-05', '4.34E-05', '0.000115513', '1.44E-05', '8.47E-06', '1.99E-05', '8.74E-06', '0.002390839', '0.000437139', '0.000257362', '3.73E-05', '3.85E-05', '1.08E-06', '1.32E-05', '0.001016546', '0.000597913', '3.62E-05', '2.71E-05', '0.001259357', '7.29E-06', '8.60E-06', '6.09E-05', '6.89E-05', '1.70E-05', '1.91E-05', '0.000198732', '2.92E-05', '6.60E-05', '7.67E-05', '2.61E-05', '0.002808081', '0.001350543', '0.000358372', '0.000242717', '6.14E-06', '3.68E-06', '0.000201375', '5.70E-05', '0.000274155', '0.00014556', '7.48E-06', '3.87E-06', '1.31E-06', '0.002421039', '0.010065535', '0.006898238', '0.000100016', '0.002731523', '0.000394906', '0.004641104', '0.01680808', '0.001079985', '6.68E-05', '4.29E-05', '7.17E-05', '7.28E-05', '6.72E-05', '0.000359383', '0.000290815', '0.001808672', '0.000736785', '0.000345332', '0.000318615', '0.001718375', '0.000681873', '0.000130193', '6.62E-05', '4.67E-05', '4.25E-05', '6.50E-06', '9.74E-06', '1.20E-05', '7.81E-06', '0.000464973', '0.003019831', '0.007116778', '0.000509456', '0.000538546', '0.001036241', '0.001807689', '0.000211422', '0.000243115', '0.000189077', '0.000201505', '8.83E-05', '0.00013841', '9.95E-05', '0.00012162', '0.000371069', '0.000264859', '6.76E-05', '5.54E-05', '0.000588303', '0.000234014', '0.000222742', '0.00021298', '7.99E-05', '4.99E-05', '0.000959625', '0.000162954', '0.000108232', '0.000125809', '0.003106199', '7.45E-05', '5.47E-05', '8.16E-05', '9.82E-05', '0.0001026', '7.53E-05', '3.79E-05', '0.000317231', '3.74E-05', '5.44E-05', '0.000170998', '0.000382116', '0.000118675', '6.20E-05', '0.000431269', '0.000783599', '0.0024141', '0.000111127', '0.00438654', '0.00151446', '0.000456342', '0.000571701', '0.000411091', '0.00027278', '0.000335825', '0.001103625', '0.004389634', '0.000552392', '0.00010145', '4.94E-06', '4.51E-06', '2.25E-06', '0.003073416', '0.001057078', '0.000177056', '2.84E-06', '7.94E-06', '0.001492816', '0.000127686', '4.34E-05', '6.26E-05', '4.58E-05', '0.000217036']



    data2 = []
    for elements in data0:
        data2.append(float(elements))
#     print('Training data')

#     print(data1)
#     print('\n\n\n')

#     print('Testing data set')
#     print(data2)
#     print('\n')

    # Plot the histograms and KDEs
    site = input('what site is this for: ')
    plt.figure(figsize=(10, 6))
    sns.histplot(data1, bins=30, kde=True, color='blue', label='Calibration data', alpha=0.5, stat="density")
    sns.histplot(data2, bins=30, kde=True, color='orange', label='Validation data', alpha=0.5, stat="density")
    nutrient = input('What nutrient is this: ')
    plt.xlabel(f'{nutrient} Loads (kg)')
    plt.ylabel('Frequency')
    plt.title(f'{site} Testing and Training data Distribution')
    plt.legend()
    plt.show()

    # resizing the plot
    # site = input('What site is this for: ')
    # plt.figure(figsize=(8, 8))  # Set figure size to make it square
    # sns.histplot(data1, bins=30, kde=True, color='blue', label='Training data', alpha=0.5, stat="density")
    # sns.histplot(data2, bins=30, kde=True, color='orange', label='Testing data', alpha=0.5, stat="density")
    # plt.xlabel('Concentration')
    # plt.ylabel('Frequency')
    # plt.title(f'{site} Testing and Training Data Distribution')
    # plt.legend()
    # plt.gca().set_aspect('equal', adjustable='box')  # Ensure the plot area is square
    # plt.show()


    # Perform statistical comparison (Kolmogorov-Smirnov Test)
    ks_stat, p_value = ks_2samp(data1, data2)

    # Print KS Test Results
    print(f"Kolmogorov-Smirnov Test:\n- KS Statistic = {ks_stat:.4f}\n- P-value = {p_value:.4f}")

    # Interpretation
    if p_value < 0.05:
        print("The two datasets have significantly different distributions (p < 0.05).")
    else:
        print("The two datasets do not have significantly different distributions (p >= 0.05).")
    
    print('''\nAlso the two distribution are the statistically similar if KS < 0.2
when 0.1 < KS < 0.2 - The distributions are on the border line of different and
KS < 0.1, they are statistically similar''')    

###################################################################################################################################################################################################################################
###################################################################################################################################################################################################################################
    
#     print(x)
#     print(y)
    y1 = x
    y2 = y
    x = []
    for elements in range(0, len(y1)):
        x.append(elements)

    # Create the plot
    plt.plot(x, y1, marker='o', linestyle='-', label="y1")  # Line for y1
    plt.plot(x, y2, marker='s', linestyle='--', label="y2")  # Line for y2

    # Labels and title
    plt.xlabel("X values")
    plt.ylabel("Y values")
    plt.title("Plot of y1 and y2 against x")
    plt.legend()  # Show legend
    plt.grid(True)  # Add grid for better readability

    # Show plot
    plt.show()

    big_y1 = []
    layer = []
    for elements in y1:
        if len(big_y1) > 0:
            layer.append(elements)
            j = sum(layer)
            big_y1.append(j)
        else:
            big_y1.append(elements)
            layer.append(elements)

#     print(big_y1)
    
    big_y2 = []
    layer = []
    for elements in y2:
        if len(big_y2) > 0:
            layer.append(elements)
            j = sum(layer)
            big_y2.append(j)
        else:
            big_y2.append(elements)
            layer.append(elements)

#     print(big_y1)
#     print(big_y2)
    
    y1 = big_y1
    y2 = big_y2
    x = []
    for elements in range(0, len(y1)):
        x.append(elements)

    # Create the plot
    plt.plot(x, y1, marker='o', linestyle='-', label="y1")  # Line for y1
    plt.plot(x, y2, marker='s', linestyle='--', label="y2")  # Line for y2

    # Labels and title
    plt.xlabel("X values")
    plt.ylabel("Y values")
    plt.title("Plot of y1 and y2 against x")
    plt.legend()  # Show legend
    plt.grid(True)  # Add grid for better readability

    # Show plot
    plt.show()
grab_data()


